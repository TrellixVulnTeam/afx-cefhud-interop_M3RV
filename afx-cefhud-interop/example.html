<!DOCTYPE html>
<!--

## Usage:

Launch CS:GO from HLAE with -afxInteropLight.

For testing execute (will open console window that can be closed and log to debug.log in current directoy):
afx-cefhud-interop.exe "--url=file:///C:/source/afx-cefhud-interop/afx-cefhud-interop/example.html" --afxConsole --enable-logging --v=1

For live execute (will run in background):
afx-cefhud-interop.exe "--url=file:///C:/source/afx-cefhud-interop/afx-cefhud-interop/example.html" --enable-logging --log-severity=error

Enter afx_interop connect 1 into CS:GO console.

Console inteface:
afx_interop send cefhud [...]


## Type descriptions:


AfxD3DMatrix = Array<Double,16>;

AfxMatrix4x4 = AfxD3DMatrix

AfxView = {
	x: Int,
	y: Int,
	width: Int,
	height: Int,
	viewMatrix: AfxMatrix4x4,
	projectionMatrix: AfxMatrix4x4
};

AfxRenderInfo = {
	view: AfxView,
    frameCount: Int, // client frame count
	absoluteFrameTime: Double, // unpaused client frame delta time
	curTime: Double, // client time
	frameTime: Double // simulated client frame time (can be 0 when paused)
};

AfxCommandArgs = String;

AfxCommand = Array<AfxCommandArgs>;

AfxCommands = Array<AfxCommand>;

AfxRenderViewBeginResult = {
	[beforeTranslucentShadow: Bool,] // optional
	[afterTranslucentShadow: Bool,] // optional
	[beforeTranslucent: Bool,] // optional
	[afterTranslucent: Bool,] // optional
	[beforeHud: Bool,] // optional
	[afterHud: Bool,] // optional
	[afterRenderView: Bool,] // optional
};

AfxViewOverrideArg = {
	tX: Double, // forward
	tY: Double, // left
	tZ: Double, // up
	rX: Double, // "pitch" (y/left-axis rotation)
	rY: Double, // "yaw" (z/up-axis rotation)
	rZ: Double, // roll (x/forward-axis rotation)
	fov: Double // unscaled engine FOV (the engine additionally scales the actual horizontal FOV by the screen aspect ratio)
};

AfxViewOverrideResult = {
	[tX: Double,] // optional, forward
	[tY: Double,] // optional, left
	[tZ: Double,] // optional, up
	[rX: Double,] // optional, "pitch" (y/left-axis rotation)
	[rY: Double,] // optional, "yaw" (z/up-axis rotation)
	[rZ: Double,] // optional, roll (x/forward-axis rotation)
	[fov: Double] // optional
};

AfxAddMirvCalcResult = {
	release: Function() // call this in order to remove / release the calc
};

AfxAddMirvCalcArgHandle {
	intHandle: Int
};

AfxAddMirvCalcVector {
	x: Double, // forward
	y: Double, // left
	z: Double // up
};

AfxAddMirvCalcQAngle {
	pitch: Double, // yRotation (left)
	yaw: Double, // zRotation (up)
	roll: Double, // xRotation (forward)
};

AfxAddMirvCalcArgVecAng {
	vector: AfxAddMirvCalcVector,
	qAngle: AfxAddMirvCalcQAngle
};

AfxAddMirvCalcArgCam {
	vector: AfxAddMirvCalcVector,
	qAngle: AfxAddMirvCalcQAngle,
	fov: Double // engine (unscaled) FOV
};

AfxAddMirvCalcArgFov {
	fov: Double
};

AfxAddMirvCalcArgBool {
	result: Bool
};

AfxAddMirvCalcArgInt {
	result: Int
};

// For AFX_RENDERPASS_STATE see code bellow.

// For AFX_GAMEVENT_ENRICHMENTS see code bellow.

AfxGameEventKey = {
	type: Int, // See AFX_GAMEVENT_TYPES
	value: String|Double|Int|Int|UInt|Bool|Array<UInt,2>, // Types are in this order: AFX_GAMEVENT_TYPES.CString AFX_GAMEVENT_TYPES.Float, AFX_GAMEVENT_TYPES.Long, AFX_GAMEVENT_TYPES.Short, AFX_GAMEVENT_TYPES.Byte, AFX_GAMEVENT_TYPES.Bool, AFX_GAMEVENT_TYPES.Uint64 (0 = lo, 1 = hi). Keys of other types are omitted.
	[enrichments: {
		[userIdWithSteamId: Array<UInt,2>,] // 0 = lo, 1 = hi.
		[entnumWithOrigin: {
			x: Double,
			y: Double,
			z: Double
		},]
		[entnumWithAngles: {
			pitch: Double,
			yaw: Double,
			roll: Double
		},]
		[useridWithEyePosition: {
			x: Double,
			y: Double,
			z: Double
		},]
		[useridWithEyeAngels: {
			pitch: Double,
			yaw: Double,
			roll: Double
		},]
	}] // If enriched this is present.
};

AfxGameEvent = {
	name: String,
	[clientTime: Double,] // Only for afxInterop.gameEventSetTransmitClientTime(1).
	[tick: Int,] // Only for afxInterop.gameEventSetTransmitTick(1).
	[systemTime: Date,] // Only for afxInterop.gameEventSetTransmitSystemTime(1).
	keys: Dictionary<key=String,value=AfxGameEventKey>
};

AfxRect: {
	left: Int,
	top: Int,
	right: Int,
	bottom: Int
};

AfxDrawingHandle: {
	release: Function(), // Always release.Strongly recommended if you don't need it anymore to save resources.
};

AfxDrawingData: extends ArrayBuffer {
};

AfxD3d9VertexDeclaration = {
	release: Function(), // Always release the vertex declaration on the client! Strongly recommended if you don't need it anymore to save resources.
};

AfxD3d9IndexBuffer = {
	release: Function(), // Always release the index buffer on the client! Strongly recommended if you don't need it anymore to save resources.
	
	// WARNING: Input is currently not fully sanitized and validated, providing bogous values might cause CEF or CS:GO to crash!
	update: Function(data: AfxDrawingData, offset: UInt, size: UInt)
};

AfxD3d9VertexBuffer= {
	release: Function(), // Always release the vertex buffer on the client! Strongly recommended if you don't need it anymore to save resources.
	
	// WARNING: Input is currently not fully sanitized and validated, providing bogous values might cause CEF or CS:GO to crash!
	update: Function(data: AfxDrawingData, offset: UInt, size: UInt)
};

AfxD3d9Texture: {
	release: Function(), // Always release the texture on the client! Strongly recommended if you don't need it anymore to save resources.
	
	// WARNING: Input is currently not fully sanitized and validated, providing bogous values might cause CEF or CS:GO to crash!
	update: Function(level: UInt, rect: null|AfxRect, data: AfxDrawingData, rowOffsetBytes: UInt, columnOffsetBytes: UInt, dataBytesPerRow: UInt, totalBytesPerRow: UInt, numRows: UInt)
};

AfxD3d9PixelShader: {
	release: Function(), // Always release the shader on the client! Strongly recommended if you don't need it anymore to save resources.	
};

AfxD3d9VertexShader: {
	release: Function(), // Always release the shader on the client! Strongly recommended if you don't need it anymore to save resources.
};

AfxD3d9Viewport: {
	x: UInt, y: UInt, width: UInt, height: UInt, minZ: Double, maxZ: Double
};

AfxInterop = {
	pipeName: String, // name part to use for the pipe (set before re-connecting)
	connect: Function() => Bool, // interop connection pump, returns true when pump is active
	getConnected: Function() => Bool, // returns true when actually connected
	close: Function(), // close connection
	onNewConnection: Function(Function()), // set function to be called upon new connection (can be also re-connect)
	onCommands: Function(Function(AfxCommands)), // set callback function that gets command from the client
	scheduleCommand: Function(String), // schedule a command string to be executed in the client (avoid scheduling too many, especially if there's no connection).
	onRenderViewBegin: Function(Function(AfxRenderInfo) [=> AfxRenderViewBeginResult]), // set funtion to be called upon begin of rendering the player view, optionally returns AfxRenderViewBeginResult object for render passes to be handled. This function can be called multiple times by the engine, e.g. due to rendering water / mirror views. For efficiency reasons it is currently best to only do one render per window / instance.
	onViewOverride: Function(Function(AfxViewOverrideArg) [=> AfxViewOverrideResult]), // set function to be called when view override is possible, optional returns AfxViewOverrideResult object.
	onRenderPass: Function(Function(AfxRenderPassState,AfxView)), // set function to be called upon rendering a renderpass.
	onHudBegin: Function(Function()), // set function to be called upon this event.
	onHudEnd: Function(Function()), // set function to be called upon this event.
	onRenderViewEnd: Function(Function()), // set function to be called upon this event.
	
	//
	// mirv_calcs related:
	
	addCalcHandle: Function(name=String,Function(null|AfxAddMirvCalcArgHandle)) => AfxAddMirvCalcResult, // Get data from a mirv_calcs handle calc (can be called with null if not available).
	addCalcVecAng: Function(name=String,Function(null|AfxAddMirvCalcArgVecAng)) => AfxAddMirvCalcResult, // Get data from a mirv_calcs vecAng calc (can be called with null if not available).
	addCalcCam: Function(name=String,Function(null|AfxAddMirvCalcArgCam)) => AfxAddMirvCalcResult, // Get data from a mirv_calcs cam calc (can be called with null if not available).
	addCalcFov: Function(name=String,Function(null|AfxAddMirvCalcArgFov)) => AfxAddMirvCalcResult, // Get data from a mirv_calcs fov calc (can be called with null if not available).
	addCalcBool: Function(name=String,Function(null|AfxAddMirvCalcArgBool)) => AfxAddMirvCalcResult, // Get data from a mirv_calcs bool calc (can be called with null if not available).
	addCalcInt: Function(name=String,Function(null|AfxAddMirvCalcArgInt)) => AfxAddMirvCalcResult, // Get data from a mirv_calcs int calc (can be called with null if not available).
	
	//
	// Game event related:
	
	gameEventAllowAdd: Function(eventName=String), // SHOULD ONLY BE USED IN THE BEFORE OR AFTER afxInterop.connect() WORKER FUNCTION AND NOT DURING EVENTS OF IT (otherwise side effect hazards ahead). Add event allowed to transferred (if empty all are allowed).
	gameEventAllowRemove: Function(eventName=String), // SHOULD ONLY BE USED IN THE BEFORE OR AFTER afxInterop.connect() WORKER FUNCTION AND NOT DURING EVENTS OF IT (otherwise side effect hazards ahead). Remove event allowed to transferred (if empty all are allowed).
	gameEventDenyAdd: Function(eventName=String), // SHOULD ONLY BE USED IN THE BEFORE OR AFTER afxInterop.connect() WORKER FUNCTION AND NOT DURING EVENTS OF IT (otherwise side effect hazards ahead). Add event to deny from transfer.
	gameEventDenyRemove: Function(eventName=String), // SHOULD ONLY BE USED IN THE BEFORE OR AFTER afxInterop.connect() WORKER FUNCTION AND NOT DURING EVENTS OF IT (otherwise side effect hazards ahead). Remove event to deny from transfer.
	gameEventSetEnrichment: Function(eventName=String,keyName=String,enrichments=UInt), // SHOULD ONLY BE USED IN THE BEFORE OR AFTER afxInterop.connect() WORKER FUNCTION AND NOT DURING EVENTS OF IT (otherwise side effect hazards ahead). Set enrichment for a key of an event. Set enrichments=0 to remove enrichment, otherwise binary OR of AFX_GAMEVENT_ENRICHMENTS properties.
	onGameEvent: Function(Function(null|AfxGameEvent)), // Set game event callback.
	gameEventSetTransmitClientTime: Function(transmit=Bool), // SHOULD ONLY BE USED IN THE BEFORE OR AFTER afxInterop.connect() WORKER FUNCTION AND NOT DURING EVENTS OF IT (otherwise side effect hazards ahead).
	gameEventSetTransmitTick: Function(transmit=Bool), // SHOULD ONLY BE USED IN THE BEFORE OR AFTER afxInterop.connect() WORKER FUNCTION AND NOT DURING EVENTS OF IT (otherwise side effect hazards ahead).
	gameEventSetTransmitSystemTime: Function(transmit=Bool), // SHOULD ONLY BE USED IN THE BEFORE OR AFTER afxInterop.connect() WORKER FUNCTION AND NOT DURING EVENTS OF IT (otherwise side effect hazards ahead).
	
	//
	// Drawing related:
	
	onDeviceReset: Function(Function()), // Use this event to restore resources after device reset (e.g. for D3DPOOL_DEFAULT).
	
	drawingConnect: Function(), // schedule drawing connection.
	drawingPumpBegin: Function(frameCount=Int), // Begin render pass / pumping messages.
	drawingPumpEnd: Function(), // End render pass / pumping messages.
	drawingBeginFrame: Function([width=Int,height=Int]), // schedule drawing of a Cef window frame, with optional width and height (e.g. from onRenderViewBegin to match the client size).
	
	d3d9CreateVertexDeclaration: Function(data: AfxDrawingData) => AfxD3d9VertexDeclaration, // https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-createvertexdeclaration // WARNING: Input is currently not fully sanitized and validated, providing bogous values might cause CS:GO to crash!
	
	d3d9CreateIndexBuffer: Function(length: UInt, usage: UInt, format: UInt, pool: UInt, pSharedHandle: null|AfxDrawingHandle) => AfxD3d9IndexBuffer, // Pool D3DPOOL_DEFAULT is strongly recommended. https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-createindexbuffer
	d3d9CreateVertexBuffer: Function(length: UInt, usage: UInt, fvf: UInt, pool: UInt, pSharedHandle: null|AfxDrawingHandle) => AfxD3d9VertexBuffer, // Pool D3DPOOL_DEFAULT is strongly recommended. https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-createvertexbuffer
	d3d9CreateTexture: Function(width: UInt, height: UInt, levels: UInt, usage: UInt, format: UInt, pool: UInt, pSharedHandle: null|AfxDrawingHandle) => AfxD3d9Texture, // Pool D3DPOOL_DEFAULT is strongly recommended. https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-createtexture
	
	d3d9CreateVertexShader: Function(data: AfxDrawingData) => AfxD3d9PixelShader, // https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-createvertexshader // WARNING: Input is currently not fully sanitized and validated, providing bogous values might cause CS:GO to crash!
	d3d9CreatePixelShader: Function(data: AfxDrawingData) => AfxD3d9VertexShader, // https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-createpixelshader // WARNING: Input is currently not fully sanitized and validated, providing bogous values might cause CS:GO to crash!
	
	d3d9UpdateTexture: Function(pSourceTexture: null|AfxD3d9Texture, pDestinationTexture: null|AfxD3d9Texture), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-updatetexture
	d3d9SetViewport: Function(null|AfxD3d9Viewport), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-setviewport
	d3d9SetRenderState: Function(state: UInt, value: UInt), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-setrenderstate
	d3d9SetSamplerState: Function(sampler: UInt, type: UInt, value: UInt), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-setsamplerstate
	d3d9SetTexture: Function(stage: UInt, pTexture: null|AfxD3d9Texture), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture
	d3d9SetTextureStageState: Function(stage: UInt, type: UInt, value: UInt), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexturestagestate
	d3d9SetTransform: Function(state: UInt, matrix: null|Array<Double,16>), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-settransform 
	d3d9SetIndices: Function(pIndexData: null|AfxD3d9IndexBuffer), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-setindices
	d3d9SetStreamSource: Function(streamNumber: UInt, pStreamData: null|AfxD3d9VertexBuffer, offsetInBytes: UInt, stride: UInt), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-setstreamsource
	d3d9SetStreamSourceFreq: Function(streamNumber: UInt, setting: UInt), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-setstreamsourcefreq	
	d3d9SetVertexDeclaration: Function(pDecl: AfxD3d9VertexDeclaration), https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-setvertexdeclaration
	d3d9SetVertexShader: Function(pShader: null|UInt), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-setvertexshader
	d3d9SetVertexShaderConstantB: Function(startRegister: UInt, Array<Bool>), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setvertexshaderconstantb
	d3d9SetVertexShaderConstantF: Function(startRegister: UInt, Array<Double>), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setvertexshaderconstantf
	d3d9SetVertexShaderConstantI: Function(startRegister: UInt, Array<Int>), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setvertexshaderconstanti
	d3d9SetPixelShader: Function(pShader: null|UInt), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-setpixelshader
	d3d9SetPixelShaderConstantB: Function(startRegister: UInt, Array<Bool>), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-setpixelshaderconstantb
	d3d9SetPixelShaderConstantF: Function(startRegister: UInt, Array<Double>), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-setpixelshaderconstantf
	d3d9SetPixelShaderConstantI: Function(startRegister: UInt, Array<Int>), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-setpixelshaderconstanti
	d3d9DrawPrimitive: Function(primitiveType: UInt, startVertex: UInt, primitiveCount: UInt), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9/nf-d3d9-idirect3ddevice9-drawprimitive
	d3d9DrawIndexedPrimitive: Function(primitiveType: UInt, baseVertexIndex: Int, minVertexIndex: UInt, numVertices: UInt, startIndex: UInt, primCount: UInt), // https://docs.microsoft.com/en-us/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive
	
	waitForGpu: Function(), // Waits for the client GPU before continuing, this is important when using shared resources (e.g. textures).
	beginCleanState: Function(), // Puts the 3D state into a safe initial state, recommended. Must not be nested.
	endCleanState: Function(), // Ends the safe state.

	createCefWindowTextureSharedHandle: Function() => AfxDrawingHandle,
	
	createDrawingData: Function(size: UInt) => AfxDrawingData
);

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays

-->
<html>
<head>
<title>Title of the document</title>
</head>
<style>
.main {
	backdrop-filter: blur(5px);
}
</style>

<body>
<div class="main" style="background: rgba(0,0,0,0.8); color: #fff; padding: 1rem;">
<h1 style="color: #00ff00">Hello World from afx-cefhud-interop</h1>
<h2>Last game events:</h2>
<div id="gameEvents" style="border:1px solid #fff"></div>
</div>
</body>

<script>
	{
		const BOOL = {
			FALSE  : 0,
			TRUE   : 1
		}
	
		const D3DRENDERSTATETYPE = {
			D3DRS_ZENABLE                   : 7,    /* D3DZBUFFERTYPE (or TRUE/FALSE for legacy) */
			D3DRS_FILLMODE                  : 8,    /* D3DFILLMODE */
			D3DRS_SHADEMODE                 : 9,    /* D3DSHADEMODE */
			D3DRS_ZWRITEENABLE              : 14,   /* TRUE to enable z writes */
			D3DRS_ALPHATESTENABLE           : 15,   /* TRUE to enable alpha tests */
			D3DRS_LASTPIXEL                 : 16,   /* TRUE for last-pixel on lines */
			D3DRS_SRCBLEND                  : 19,   /* D3DBLEND */
			D3DRS_DESTBLEND                 : 20,   /* D3DBLEND */
			D3DRS_CULLMODE                  : 22,   /* D3DCULL */
			D3DRS_ZFUNC                     : 23,   /* D3DCMPFUNC */
			D3DRS_ALPHAREF                  : 24,   /* D3DFIXED */
			D3DRS_ALPHAFUNC                 : 25,   /* D3DCMPFUNC */
			D3DRS_DITHERENABLE              : 26,   /* TRUE to enable dithering */
			D3DRS_ALPHABLENDENABLE          : 27,   /* TRUE to enable alpha blending */
			D3DRS_FOGENABLE                 : 28,   /* TRUE to enable fog blending */
			D3DRS_SPECULARENABLE            : 29,   /* TRUE to enable specular */
			D3DRS_FOGCOLOR                  : 34,   /* D3DCOLOR */
			D3DRS_FOGTABLEMODE              : 35,   /* D3DFOGMODE */
			D3DRS_FOGSTART                  : 36,   /* Fog start (for both vertex and pixel fog) */
			D3DRS_FOGEND                    : 37,   /* Fog end      */
			D3DRS_FOGDENSITY                : 38,   /* Fog density  */
			D3DRS_RANGEFOGENABLE            : 48,   /* Enables range-based fog */
			D3DRS_STENCILENABLE             : 52,   /* BOOL enable/disable stenciling */
			D3DRS_STENCILFAIL               : 53,   /* D3DSTENCILOP to do if stencil test fails */
			D3DRS_STENCILZFAIL              : 54,   /* D3DSTENCILOP to do if stencil test passes and Z test fails */
			D3DRS_STENCILPASS               : 55,   /* D3DSTENCILOP to do if both stencil and Z tests pass */
			D3DRS_STENCILFUNC               : 56,   /* D3DCMPFUNC fn.  Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true */
			D3DRS_STENCILREF                : 57,   /* Reference value used in stencil test */
			D3DRS_STENCILMASK               : 58,   /* Mask value used in stencil test */
			D3DRS_STENCILWRITEMASK          : 59,   /* Write mask applied to values written to stencil buffer */
			D3DRS_TEXTUREFACTOR             : 60,   /* D3DCOLOR used for multi-texture blend */
			D3DRS_WRAP0                     : 128,  /* wrap for 1st texture coord. set */
			D3DRS_WRAP1                     : 129,  /* wrap for 2nd texture coord. set */
			D3DRS_WRAP2                     : 130,  /* wrap for 3rd texture coord. set */
			D3DRS_WRAP3                     : 131,  /* wrap for 4th texture coord. set */
			D3DRS_WRAP4                     : 132,  /* wrap for 5th texture coord. set */
			D3DRS_WRAP5                     : 133,  /* wrap for 6th texture coord. set */
			D3DRS_WRAP6                     : 134,  /* wrap for 7th texture coord. set */
			D3DRS_WRAP7                     : 135,  /* wrap for 8th texture coord. set */
			D3DRS_CLIPPING                  : 136,
			D3DRS_LIGHTING                  : 137,
			D3DRS_AMBIENT                   : 139,
			D3DRS_FOGVERTEXMODE             : 140,
			D3DRS_COLORVERTEX               : 141,
			D3DRS_LOCALVIEWER               : 142,
			D3DRS_NORMALIZENORMALS          : 143,
			D3DRS_DIFFUSEMATERIALSOURCE     : 145,
			D3DRS_SPECULARMATERIALSOURCE    : 146,
			D3DRS_AMBIENTMATERIALSOURCE     : 147,
			D3DRS_EMISSIVEMATERIALSOURCE    : 148,
			D3DRS_VERTEXBLEND               : 151,
			D3DRS_CLIPPLANEENABLE           : 152,
			D3DRS_POINTSIZE                 : 154,   /* float point size */
			D3DRS_POINTSIZE_MIN             : 155,   /* float point size min threshold */
			D3DRS_POINTSPRITEENABLE         : 156,   /* BOOL point texture coord control */
			D3DRS_POINTSCALEENABLE          : 157,   /* BOOL point size scale enable */
			D3DRS_POINTSCALE_A              : 158,   /* float point attenuation A value */
			D3DRS_POINTSCALE_B              : 159,   /* float point attenuation B value */
			D3DRS_POINTSCALE_C              : 160,   /* float point attenuation C value */
			D3DRS_MULTISAMPLEANTIALIAS      : 161,  // BOOL - set to do FSAA with multisample buffer
			D3DRS_MULTISAMPLEMASK           : 162,  // DWORD - per-sample enable/disable
			D3DRS_PATCHEDGESTYLE            : 163,  // Sets whether patch edges will use float style tessellation
			D3DRS_DEBUGMONITORTOKEN         : 165,  // DEBUG ONLY - token to debug monitor
			D3DRS_POINTSIZE_MAX             : 166,   /* float point size max threshold */
			D3DRS_INDEXEDVERTEXBLENDENABLE  : 167,
			D3DRS_COLORWRITEENABLE          : 168,  // per-channel write enable
			D3DRS_TWEENFACTOR               : 170,   // float tween factor
			D3DRS_BLENDOP                   : 171,   // D3DBLENDOP setting
			D3DRS_POSITIONDEGREE            : 172,   // NPatch position interpolation degree. D3DDEGREE_LINEAR or D3DDEGREE_CUBIC (default)
			D3DRS_NORMALDEGREE              : 173,   // NPatch normal interpolation degree. D3DDEGREE_LINEAR (default) or D3DDEGREE_QUADRATIC
			D3DRS_SCISSORTESTENABLE         : 174,
			D3DRS_SLOPESCALEDEPTHBIAS       : 175,
			D3DRS_ANTIALIASEDLINEENABLE     : 176,
			D3DRS_MINTESSELLATIONLEVEL      : 178,
			D3DRS_MAXTESSELLATIONLEVEL      : 179,
			D3DRS_ADAPTIVETESS_X            : 180,
			D3DRS_ADAPTIVETESS_Y            : 181,
			D3DRS_ADAPTIVETESS_Z            : 182,
			D3DRS_ADAPTIVETESS_W            : 183,
			D3DRS_ENABLEADAPTIVETESSELLATION : 184,
			D3DRS_TWOSIDEDSTENCILMODE       : 185,   /* BOOL enable/disable 2 sided stenciling */
			D3DRS_CCW_STENCILFAIL           : 186,   /* D3DSTENCILOP to do if ccw stencil test fails */
			D3DRS_CCW_STENCILZFAIL          : 187,   /* D3DSTENCILOP to do if ccw stencil test passes and Z test fails */
			D3DRS_CCW_STENCILPASS           : 188,   /* D3DSTENCILOP to do if both ccw stencil and Z tests pass */
			D3DRS_CCW_STENCILFUNC           : 189,   /* D3DCMPFUNC fn.  ccw Stencil Test passes if ((ref & mask) stencilfn (stencil & mask)) is true */
			D3DRS_COLORWRITEENABLE1         : 190,   /* Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS */
			D3DRS_COLORWRITEENABLE2         : 191,   /* Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS */
			D3DRS_COLORWRITEENABLE3         : 192,   /* Additional ColorWriteEnables for the devices that support D3DPMISCCAPS_INDEPENDENTWRITEMASKS */
			D3DRS_BLENDFACTOR               : 193,   /* D3DCOLOR used for a constant blend factor during alpha blending for devices that support D3DPBLENDCAPS_BLENDFACTOR */
			D3DRS_SRGBWRITEENABLE           : 194,   /* Enable rendertarget writes to be DE-linearized to SRGB (for formats that expose D3DUSAGE_QUERY_SRGBWRITE) */
			D3DRS_DEPTHBIAS                 : 195,
			D3DRS_WRAP8                     : 198,   /* Additional wrap states for vs_3_0+ attributes with D3DDECLUSAGE_TEXCOORD */
			D3DRS_WRAP9                     : 199,
			D3DRS_WRAP10                    : 200,
			D3DRS_WRAP11                    : 201,
			D3DRS_WRAP12                    : 202,
			D3DRS_WRAP13                    : 203,
			D3DRS_WRAP14                    : 204,
			D3DRS_WRAP15                    : 205,
			D3DRS_SEPARATEALPHABLENDENABLE  : 206,  /* TRUE to enable a separate blending function for the alpha channel */
			D3DRS_SRCBLENDALPHA             : 207,  /* SRC blend factor for the alpha channel when D3DRS_SEPARATEDESTALPHAENABLE is TRUE */
			D3DRS_DESTBLENDALPHA            : 208,  /* DST blend factor for the alpha channel when D3DRS_SEPARATEDESTALPHAENABLE is TRUE */
			D3DRS_BLENDOPALPHA              : 209   /* Blending operation for the alpha channel when D3DRS_SEPARATEDESTALPHAENABLE is TRUE */
		};
		
		const D3DBLEND = {
			D3DBLEND_ZERO               : 1,
			D3DBLEND_ONE                : 2,
			D3DBLEND_SRCCOLOR           : 3,
			D3DBLEND_INVSRCCOLOR        : 4,
			D3DBLEND_SRCALPHA           : 5,
			D3DBLEND_INVSRCALPHA        : 6,
			D3DBLEND_DESTALPHA          : 7,
			D3DBLEND_INVDESTALPHA       : 8,
			D3DBLEND_DESTCOLOR          : 9,
			D3DBLEND_INVDESTCOLOR       : 10,
			D3DBLEND_SRCALPHASAT        : 11,
			D3DBLEND_BOTHSRCALPHA       : 12,
			D3DBLEND_BOTHINVSRCALPHA    : 13,
			D3DBLEND_BLENDFACTOR        : 14, /* Only supported if D3DPBLENDCAPS_BLENDFACTOR is on */
			D3DBLEND_INVBLENDFACTOR     : 15, /* Only supported if D3DPBLENDCAPS_BLENDFACTOR is on */
			/* D3D9Ex only -- */

			D3DBLEND_SRCCOLOR2          : 16,
			D3DBLEND_INVSRCCOLOR2       : 17

			/* -- D3D9Ex only */
		};
		
		const D3DZBUFFERTYPE = {
			D3DZB_FALSE                 : 0,
			D3DZB_TRUE                  : 1, // Z buffering
			D3DZB_USEW                  : 2  // W buffering
		};
		
		const D3DCMPFUNC = {
			D3DCMP_NEVER                : 1,
			D3DCMP_LESS                 : 2,
			D3DCMP_EQUAL                : 3,
			D3DCMP_LESSEQUAL            : 4,
			D3DCMP_GREATER              : 5,
			D3DCMP_NOTEQUAL             : 6,
			D3DCMP_GREATEREQUAL         : 7,
			D3DCMP_ALWAYS               : 8
		};
		
		const D3DCULL = {
			D3DCULL_NONE                : 1,
			D3DCULL_CW                  : 2,
			D3DCULL_CCW                 : 3
		};
		
		const D3DRS_COLORWRITEENABLE = {
			D3DCOLORWRITEENABLE_RED    : (1<<0),
			D3DCOLORWRITEENABLE_GREEN  : (1<<1),
			D3DCOLORWRITEENABLE_BLUE   : (1<<2),
			D3DCOLORWRITEENABLE_ALPHA  : (1<<3)
		};
		
		const D3DDECLTYPE = { 
			D3DDECLTYPE_FLOAT1     : 0,
			D3DDECLTYPE_FLOAT2     : 1,
			D3DDECLTYPE_FLOAT3     : 2,
			D3DDECLTYPE_FLOAT4     : 3,
			D3DDECLTYPE_D3DCOLOR   : 4,
			D3DDECLTYPE_UBYTE4     : 5,
			D3DDECLTYPE_SHORT2     : 6,
			D3DDECLTYPE_SHORT4     : 7,
			D3DDECLTYPE_UBYTE4N    : 8,
			D3DDECLTYPE_SHORT2N    : 9,
			D3DDECLTYPE_SHORT4N    : 10,
			D3DDECLTYPE_USHORT2N   : 11,
			D3DDECLTYPE_USHORT4N   : 12,
			D3DDECLTYPE_UDEC3      : 13,
			D3DDECLTYPE_DEC3N      : 14,
			D3DDECLTYPE_FLOAT16_2  : 15,
			D3DDECLTYPE_FLOAT16_4  : 16,
			D3DDECLTYPE_UNUSED     : 17
		};
		
		const D3DDECLMETHOD = { 
			D3DDECLMETHOD_DEFAULT           : 0,
			D3DDECLMETHOD_PARTIALU          : 1,
			D3DDECLMETHOD_PARTIALV          : 2,
			D3DDECLMETHOD_CROSSUV           : 3,
			D3DDECLMETHOD_UV                : 4,
			D3DDECLMETHOD_LOOKUP            : 5,
			D3DDECLMETHOD_LOOKUPPRESAMPLED  : 6
		};
		
		const D3DDECLUSAGE = { 
			D3DDECLUSAGE_POSITION      : 0,
			D3DDECLUSAGE_BLENDWEIGHT   : 1,
			D3DDECLUSAGE_BLENDINDICES  : 2,
			D3DDECLUSAGE_NORMAL        : 3,
			D3DDECLUSAGE_PSIZE         : 4,
			D3DDECLUSAGE_TEXCOORD      : 5,
			D3DDECLUSAGE_TANGENT       : 6,
			D3DDECLUSAGE_BINORMAL      : 7,
			D3DDECLUSAGE_TESSFACTOR    : 8,
			D3DDECLUSAGE_POSITIONT     : 9,
			D3DDECLUSAGE_COLOR         : 10,
			D3DDECLUSAGE_FOG           : 11,
			D3DDECLUSAGE_DEPTH         : 12,
			D3DDECLUSAGE_SAMPLE        : 13
		};
		
		const D3DFILLMODE = {
			D3DFILL_POINT               : 1,
			D3DFILL_WIREFRAME           : 2,
			D3DFILL_SOLID               : 3
		};
		
		const D3DTEXTURESTAGESTATETYPE = {
			D3DTSS_COLOROP        :  1, /* D3DTEXTUREOP - per-stage blending controls for color channels */
			D3DTSS_COLORARG1      :  2, /* D3DTA_* (texture arg) */
			D3DTSS_COLORARG2      :  3, /* D3DTA_* (texture arg) */
			D3DTSS_ALPHAOP        :  4, /* D3DTEXTUREOP - per-stage blending controls for alpha channel */
			D3DTSS_ALPHAARG1      :  5, /* D3DTA_* (texture arg) */
			D3DTSS_ALPHAARG2      :  6, /* D3DTA_* (texture arg) */
			D3DTSS_BUMPENVMAT00   :  7, /* float (bump mapping matrix) */
			D3DTSS_BUMPENVMAT01   :  8, /* float (bump mapping matrix) */
			D3DTSS_BUMPENVMAT10   :  9, /* float (bump mapping matrix) */
			D3DTSS_BUMPENVMAT11   : 10, /* float (bump mapping matrix) */
			D3DTSS_TEXCOORDINDEX  : 11, /* identifies which set of texture coordinates index this texture */
			D3DTSS_BUMPENVLSCALE  : 22, /* float scale for bump map luminance */
			D3DTSS_BUMPENVLOFFSET : 23, /* float offset for bump map luminance */
			D3DTSS_TEXTURETRANSFORMFLAGS : 24, /* D3DTEXTURETRANSFORMFLAGS controls texture transform */
			D3DTSS_COLORARG0      : 26, /* D3DTA_* third arg for triadic ops */
			D3DTSS_ALPHAARG0      : 27, /* D3DTA_* third arg for triadic ops */
			D3DTSS_RESULTARG      : 28, /* D3DTA_* arg for result (CURRENT or TEMP) */
			D3DTSS_CONSTANT       : 32  /* Per-stage constant D3DTA_CONSTANT */
		};
		
		const D3DTEXTUREOP = {
			// Control
			D3DTOP_DISABLE              : 1,      // disables stage
			D3DTOP_SELECTARG1           : 2,      // the default
			D3DTOP_SELECTARG2           : 3,

			// Modulate
			D3DTOP_MODULATE             : 4,      // multiply args together
			D3DTOP_MODULATE2X           : 5,      // multiply and  1 bit
			D3DTOP_MODULATE4X           : 6,      // multiply and  2 bits

			// Add
			D3DTOP_ADD                  :  7,   // add arguments together
			D3DTOP_ADDSIGNED            :  8,   // add with -0.5 bias
			D3DTOP_ADDSIGNED2X          :  9,   // as above but left  1 bit
			D3DTOP_SUBTRACT             : 10,   // Arg1 - Arg2, with no saturation
			D3DTOP_ADDSMOOTH            : 11,   // add 2 args, subtract product
												// Arg1 + Arg2 - Arg1*Arg2
												// : Arg1 + (1-Arg1)*Arg2

			// Linear alpha blend: Arg1*(Alpha) + Arg2*(1-Alpha)
			D3DTOP_BLENDDIFFUSEALPHA    : 12, // iterated alpha
			D3DTOP_BLENDTEXTUREALPHA    : 13, // texture alpha
			D3DTOP_BLENDFACTORALPHA     : 14, // alpha from D3DRS_TEXTUREFACTOR

			// Linear alpha blend with pre-multiplied arg1 input: Arg1 + Arg2*(1-Alpha)
			D3DTOP_BLENDTEXTUREALPHAPM  : 15, // texture alpha
			D3DTOP_BLENDCURRENTALPHA    : 16, // by alpha of current color

			// Specular mapping
			D3DTOP_PREMODULATE            : 17,     // modulate with next texture before use
			D3DTOP_MODULATEALPHA_ADDCOLOR : 18,     // Arg1.RGB + Arg1.A*Arg2.RGB
													// COLOROP only
			D3DTOP_MODULATECOLOR_ADDALPHA : 19,     // Arg1.RGB*Arg2.RGB + Arg1.A
													// COLOROP only
			D3DTOP_MODULATEINVALPHA_ADDCOLOR : 20,  // (1-Arg1.A)*Arg2.RGB + Arg1.RGB
													// COLOROP only
			D3DTOP_MODULATEINVCOLOR_ADDALPHA : 21,  // (1-Arg1.RGB)*Arg2.RGB + Arg1.A
													// COLOROP only

			// Bump mapping
			D3DTOP_BUMPENVMAP           : 22, // per pixel env map perturbation
			D3DTOP_BUMPENVMAPLUMINANCE  : 23, // with luminance channel

			// This can do either diffuse or specular bump mapping with correct input.
			// Performs the function (Arg1.R*Arg2.R + Arg1.G*Arg2.G + Arg1.B*Arg2.B)
			// where each component has been scaled and offset to make it signed.
			// The result is replicated into all four (including alpha) channels.
			// This is a valid COLOROP only.
			D3DTOP_DOTPRODUCT3          : 24,

			// Triadic ops
			D3DTOP_MULTIPLYADD          : 25, // Arg0 + Arg1*Arg2
			D3DTOP_LERP                 : 26  // (Arg0)*Arg1 + (1-Arg0)*Arg2
		};
		
		const D3DTEXTUREARG = {
			D3DTA_SELECTMASK      : 0x0000000f, // mask for arg selector
			D3DTA_DIFFUSE         : 0x00000000, // select diffuse color (read only)
			D3DTA_CURRENT         : 0x00000001, // select stage destination register (read/write)
			D3DTA_TEXTURE         : 0x00000002, // select texture color (read only)
			D3DTA_TFACTOR         : 0x00000003, // select D3DRS_TEXTUREFACTOR (read only)
			D3DTA_SPECULAR        : 0x00000004, // select specular color (read only)
			D3DTA_TEMP            : 0x00000005, // select temporary register color (read/write)
			D3DTA_CONSTANT        : 0x00000006, // select texture stage constant
			D3DTA_COMPLEMENT      : 0x00000010, // take 1.0 - x (read modifier)
			D3DTA_ALPHAREPLICATE  : 0x00000020  // replicate alpha to color components (read modifier)
		};
		
		const D3DTEXTUREFILTERTYPE = {
			D3DTEXF_NONE            : 0,    // filtering disabled (valid for mip filter only)
			D3DTEXF_POINT           : 1,    // nearest
			D3DTEXF_LINEAR          : 2,    // linear interpolation
			D3DTEXF_ANISOTROPIC     : 3,    // anisotropic
			D3DTEXF_PYRAMIDALQUAD   : 6,    // 4-sample tent
			D3DTEXF_GAUSSIANQUAD    : 7,    // 4-sample gaussian
		/* D3D9Ex only -- */

			D3DTEXF_CONVOLUTIONMONO : 8     // Convolution filter for monochrome textures

		/* -- D3D9Ex only */
		};
		
		const D3DSAMPLERSTATETYPE = {
			D3DSAMP_ADDRESSU       : 1,  /* D3DTEXTUREADDRESS for U coordinate */
			D3DSAMP_ADDRESSV       : 2,  /* D3DTEXTUREADDRESS for V coordinate */
			D3DSAMP_ADDRESSW       : 3,  /* D3DTEXTUREADDRESS for W coordinate */
			D3DSAMP_BORDERCOLOR    : 4,  /* D3DCOLOR */
			D3DSAMP_MAGFILTER      : 5,  /* D3DTEXTUREFILTER filter to use for magnification */
			D3DSAMP_MINFILTER      : 6,  /* D3DTEXTUREFILTER filter to use for minification */
			D3DSAMP_MIPFILTER      : 7,  /* D3DTEXTUREFILTER filter to use between mipmaps during minification */
			D3DSAMP_MIPMAPLODBIAS  : 8,  /* float Mipmap LOD bias */
			D3DSAMP_MAXMIPLEVEL    : 9,  /* DWORD 0..(n-1) LOD index of largest map to use (0 :: largest) */
			D3DSAMP_MAXANISOTROPY  : 10, /* DWORD maximum anisotropy */
			D3DSAMP_SRGBTEXTURE    : 11, /* Default : 0 (which means Gamma 1.0,
										   no correction required.) else correct for
										   Gamma : 2.2 */
			D3DSAMP_ELEMENTINDEX   : 12, /* When multi-element texture is assigned to sampler, this
											indicates which element index to use.  Default : 0.  */
			D3DSAMP_DMAPOFFSET     : 13  /* Offset in vertices in the pre-sampled displacement map.
											Only valid for D3DDMAPSAMPLER sampler  */
		};
		
		const D3DUSAGE = {
			D3DUSAGE_RENDERTARGET  : 0x00000001,
			D3DUSAGE_DEPTHSTENCIL  : 0x00000002,
			D3DUSAGE_DYNAMIC       : 0x00000200,
			/* D3D9Ex only -- */

			D3DUSAGE_NONSECURE          : 00800000,

			/* -- D3D9Ex only */

			// When passed to CheckDeviceFormat, D3DUSAGE_AUTOGENMIPMAP may return
			// D3DOK_NOAUTOGEN if the device doesn't support autogeneration for that format.
			// D3DOK_NOAUTOGEN is a success code, not a failure code... the SUCCEEDED and FAILED macros
			// will return true and false respectively for this code.
			D3DUSAGE_AUTOGENMIPMAP      : 00000400,
			D3DUSAGE_DMAP               : 00004000,

			// The following usages are valid only for querying CheckDeviceFormat
			D3DUSAGE_QUERY_LEGACYBUMPMAP            : 00008000,
			D3DUSAGE_QUERY_SRGBREAD                 : 00010000,
			D3DUSAGE_QUERY_FILTER                   : 00020000,
			D3DUSAGE_QUERY_SRGBWRITE                : 00040000,
			D3DUSAGE_QUERY_POSTPIXELSHADER_BLENDING : 00080000,
			D3DUSAGE_QUERY_VERTEXTEXTURE            : 00100000,
			D3DUSAGE_QUERY_WRAPANDMIP	            : 00200000,

			/* Usages for Vertex/Index buffers */
			D3DUSAGE_WRITEONLY          : 00000008,
			D3DUSAGE_SOFTWAREPROCESSING : 00000010,
			D3DUSAGE_DONOTCLIP          : 00000020,
			D3DUSAGE_POINTS             : 00000040,
			D3DUSAGE_RTPATCHES          : 00000080,
			D3DUSAGE_NPATCHES           : 00000100,

			/* D3D9Ex only -- */

			D3DUSAGE_TEXTAPI                         : 10000000,
			D3DUSAGE_RESTRICTED_CONTENT              : 00000800,
			D3DUSAGE_RESTRICT_SHARED_RESOURCE        : 00002000,
			D3DUSAGE_RESTRICT_SHARED_RESOURCE_DRIVER : 00001000, 

			/* -- D3D9Ex only */
		};
		
		const D3DPOOL = {
			D3DPOOL_DEFAULT                 : 0,
			D3DPOOL_MANAGED                 : 1,
			D3DPOOL_SYSTEMMEM               : 2,
			D3DPOOL_SCRATCH                 : 3
		};
		
		const D3DPRIMITIVETYPE = { 
			D3DPT_POINTLIST      : 1,
			D3DPT_LINELIST       : 2,
			D3DPT_LINESTRIP      : 3,
			D3DPT_TRIANGLELIST   : 4,
			D3DPT_TRIANGLESTRIP  : 5,
			D3DPT_TRIANGLEFAN    : 6
		};
		
		const D3DTRANSFORMSTATETYPE = {
			D3DTS_VIEW          : 2,
			D3DTS_PROJECTION    : 3,
			D3DTS_TEXTURE0      : 16,
			D3DTS_TEXTURE1      : 17,
			D3DTS_TEXTURE2      : 18,
			D3DTS_TEXTURE3      : 19,
			D3DTS_TEXTURE4      : 20,
			D3DTS_TEXTURE5      : 21,
			D3DTS_TEXTURE6      : 22,
			D3DTS_TEXTURE7      : 23,
			
			D3DTS_WORLD  : (256 + 0),
			D3DTS_WORLD1 : (256 + 1),
			D3DTS_WORLD2 : (256 + 2),
			D3DTS_WORLD3 : (256 + 3),
		};
		
		///////////////////////////////
	
		var AFX_GAMEVENT_ENRICHMENTS = {
			UserIdWithSteamId: (1 << 0),
			EntnumWithOrigin: (1 << 1),
			EntnumWithAngles: (1 << 2),
			UseridWithEyePosition: (1 << 3),
			UseridWithEyeAngels: (1<<4)
		};
	
		var AFX_GAMEVENT_TYPES = {
			Local: 0,
			CString: 1,
			Float: 2,
			Long: 3,
			Short: 4,
			Byte: 5,
			Bool: 6,
			Uint64: 7
		}

		var AFX_RENDERPASS_STATE = {
			BeforeTranslucentShadow: 2,
			AfterTranslucentShadow: 3,
			BeforeTranslucent: 4,
			AfterTranslucent: 5
		};
		
		var afxInterop = window.afxInterop;
		var afxPass = null;
		var afxRenderInfo = null;
		
		var afxNewConnection = true;
		var afxDeviceReset = true;
		
		var firstConnection = true;
		var reload = false;
		var divGameEvents = document.getElementById('gameEvents');
		
		///////////////////////////////
		
		function base64ToArrayBuffer(base64_string) {
			var data = atob(base64_string);
			var arrayBuffer = new ArrayBuffer(data.length);
			var arrayBufferView = new Uint8Array(arrayBuffer);
			for (var i = 0; i < data.length; ++i) {
				arrayBufferView[i] = data.charCodeAt(i);
			}
			return arrayBuffer;
		}
		
		function createFirstAcsShaderEntryData(base64_string) {
		
			var buffer = base64ToArrayBuffer(base64_string);
			var bufferView = new DataView(buffer);
			
			var version = bufferView.getInt32(0, true);
			if(0 == version)
			{
				var entries = bufferView.getInt32(4, true);
				if(1 <= entries)
				{
					var key = bufferView.getInt32(8, true);
					var offset = bufferView.getInt32(12, true);
					var length = 0;
					if(1 == entries)
						length = buffer.byteLength - offset;
					else
					{
						var nextOffset = bufferView.getInt32(12+4+4, true);
						length = nextOffset - offset;
					}
					
					var dd = afxInterop.createDrawingData(length);
					var dv = new DataView(dd.buffer);
					
					for(var i = 0; i < length; ++i)
					{
						dv.setUint8(i, bufferView.getUint8(offset+i));
					}
					
					dd.update(0,dd.buffer.byteLength);
					
					return dd;
				}
			}
		}
		
		const shaderData = {
			"afx_drawtexture_ps20.acs": createFirstAcsShaderEntryData("AAAAAAEAAAAAAAAAEAAAAAAC///+/yMAQ1RBQhwAAABfAAAAAAL//wEAAAAcAAAAAIEAAFgAAAAwAAAAAwAAAAEAAgBIAAAAAAAAAGdfc0RlcHRoVGV4dHVyZVNhbXBsZXIAqwQADAABAAEAAQAAAAAAAABwc18yXzAATWljcm9zb2Z0IChSKSBITFNMIFNoYWRlciBDb21waWxlciAxMC4xAKsfAAACAAAAgAAAA7AfAAACAAAAkAAID6BCAAADAAAPgAAA5LAACOSgAQAAAgAID4AAAOSA//8AAA==")
		};
		
		
		var shaders = {
			"afx_drawtexture_ps20": null,
		};
		
		function buildD3d9VertexElements(definitions) {
		
			var dd = afxInterop.createDrawingData(8 * (definitions.length + 1));
			var dv = new DataView(dd.buffer);
			var i = 0;
			for(; i < definitions.length; ++i)
			{
				dv.setUint16(i*8 +  0, definitions.stream,true);
				dv.setUint16(i*8 +  2, definitions.offset,true);
				dv.setUint8(i*8 +  4, definitions.type);
				dv.setUint8(i*8 +  5, definitions.method);
				dv.setUint8(i*8 +  6, definitions.usage);
				dv.setUint8(i*8 +  7, definitions.usageIndex);
			}
			
			// append D3DDECL_END:
			dv.setUint16(i*8 +  0, 0xff,true);
			dv.setUint16(i*8 +  2, 0,true);
			dv.setUint8(i*8 +  4, 17);
			dv.setUint8(i*8 +  5, 0);
			dv.setUint8(i*8 +  6, 0);
			dv.setUint8(i*8 +  7, 0);
			
			dd.update(0,dd.buffer.byteLength);
			
			return dd;
		}
		
		const vertexElements = {
			"pos3_uv2": buildD3d9VertexElements([
				{
					stream: 0,
					offset: 0,
					type: D3DDECLTYPE.D3DDECLTYPE_FLOAT3,
					method: D3DDECLMETHOD.D3DDECLMETHOD_DEFAULT,
					usage: D3DDECLUSAGE.D3DDECLUSAGE_POSITION, usageIndex: 0
				},
				{
					stream: 1,
					offset: 3*4,
					type: D3DDECLTYPE.D3DDECLTYPE_FLOAT1,
					method: D3DDECLMETHOD.D3DDECLMETHOD_DEFAULT,
					usage: D3DDECLUSAGE.D3DDECLUSAGE_TEXCOORD, usageIndex: 1
				},
			])
		};
		
		var vertexDeclarations = {
			"pos3_uv2": null
		};
		
		var vertexBuffers = {
			"rect": null
		}
		
		function drawRect2d(texture,x,y,width,height,x0,y0,x1,y1) {
		
			afxInterop.beginCleanState();
			
			afxInterop.d3d9SetVertexDeclaration(vertexDeclarations["pos3_uv2"]);
			
			afxInterop.d3d9SetViewport({
				"x": x,
				"y": y,
				"width": width,	
				"height": height,
				"minZ": 0.0,
				"maxZ": 1.0
			});
			
			afxInterop.d3d9SetRenderState(D3DRENDERSTATETYPE.D3DRS_SRGBWRITEENABLE, BOOL.FALSE);
			afxInterop.d3d9SetRenderState(D3DRENDERSTATETYPE.D3DRS_COLORWRITEENABLE, D3DRS_COLORWRITEENABLE.D3DCOLORWRITEENABLE_ALPHA | D3DRS_COLORWRITEENABLE.D3DCOLORWRITEENABLE_BLUE | D3DRS_COLORWRITEENABLE.D3DCOLORWRITEENABLE_GREEN | D3DRS_COLORWRITEENABLE.D3DCOLORWRITEENABLE_RED);
			afxInterop.d3d9SetRenderState(D3DRENDERSTATETYPE.D3DRS_SEPARATEALPHABLENDENABLE, BOOL.FALSE);
			
			afxInterop.d3d9SetVertexShader(null);
			afxInterop.d3d9SetPixelShader(shaders["afx_drawtexture_ps20"]);
			
			afxInterop.d3d9SetRenderState(D3DRENDERSTATETYPE.D3DRS_CULLMODE, D3DCULL.D3DCULL_NONE);
			afxInterop.d3d9SetRenderState(D3DRENDERSTATETYPE.D3DRS_ZWRITEENABLE, BOOL.FALSE);
			afxInterop.d3d9SetRenderState(D3DRENDERSTATETYPE.D3DRS_ZFUNC, D3DCMPFUNC.D3DCMP_ALWAYS); // redundant due to ZENABLE
			afxInterop.d3d9SetRenderState(D3DRENDERSTATETYPE.D3DRS_ZENABLE, D3DZBUFFERTYPE.D3DZB_FALSE);
			afxInterop.d3d9SetRenderState(D3DRENDERSTATETYPE.D3DRS_ALPHABLENDENABLE, BOOL.TRUE);
			afxInterop.d3d9SetRenderState(D3DRENDERSTATETYPE.D3DRS_ALPHATESTENABLE, BOOL.FALSE);
			afxInterop.d3d9SetRenderState(D3DRENDERSTATETYPE.D3DRS_MULTISAMPLEANTIALIAS, BOOL.FALSE);
			afxInterop.d3d9SetRenderState(D3DRENDERSTATETYPE.D3DRS_LIGHTING, BOOL.FALSE);
			afxInterop.d3d9SetRenderState(D3DRENDERSTATETYPE.D3DRS_SRCBLEND, D3DBLEND.D3DBLEND_SRCALPHA);
			afxInterop.d3d9SetRenderState(D3DRENDERSTATETYPE.D3DRS_DESTBLEND, D3DBLEND.D3DBLEND_INVSRCALPHA);
			afxInterop.d3d9SetRenderState(D3DRENDERSTATETYPE.D3DRS_FILLMODE, D3DBLEND.D3DFILL_SOLID);

			afxInterop.d3d9SetTextureStageState(0, D3DTEXTURESTAGESTATETYPE.D3DTSS_COLOROP, D3DTEXTUREOP.D3DTOP_SELECTARG1);
			afxInterop.d3d9SetTextureStageState(0, D3DTEXTURESTAGESTATETYPE.D3DTSS_COLORARG1, D3DTEXTUREARG.D3DTA_TEXTURE);
			afxInterop.d3d9SetTextureStageState(0, D3DTEXTURESTAGESTATETYPE.D3DTSS_ALPHAOP, D3DTEXTUREOP.D3DTOP_SELECTARG1);
			afxInterop.d3d9SetTextureStageState(0, D3DTEXTURESTAGESTATETYPE.D3DTSS_ALPHAARG1, D3DTEXTUREARG.D3DTA_TEXTURE);

			afxInterop.d3d9SetSamplerState(0, D3DSAMPLERSTATETYPE.D3DSAMP_MINFILTER, D3DTEXTUREFILTERTYPE.D3DTEXF_LINEAR);
			afxInterop.d3d9SetSamplerState(0, D3DSAMPLERSTATETYPE.D3DSAMP_MAGFILTER, D3DTEXTUREFILTERTYPE.D3DTEXF_LINEAR);
			afxInterop.d3d9SetSamplerState(0, D3DSAMPLERSTATETYPE.D3DSAMP_SRGBTEXTURE, BOOL.FALSE);
			
			// texture:
			afxInterop.d3d9SetTexture(0, texture);
			
			// Setup orthographic projection matrix
			{
				const L = 0.5 + x;
				const R = 0.5 + x + width;
				const T = (0.5 + y);
				const B = (0.5 + y + height);
				const mat_identity = [
					1.0, 0.0, 0.0, 0.0,
					0.0, 1.0, 0.0, 0.0,
					0.0, 0.0, 1.0, 0.0,
					0.0, 0.0, 0.0, 1.0
				];
				const mat_projection = [
					2.0 / (R - L)    , 0.0              , 0.0, 0.0,
					0.0              , 2.0 / (T - B)    , 0.0, 0.0,
					0.0              , 0.0              , 0.5, 0.0,
					(L + R) / (L - R), (T + B) / (B - T), 0.5, 1.0
				];
				afxInterop.d3d9SetTransform(D3DTRANSFORMSTATETYPE.D3DTS_WORLD, mat_identity);
				afxInterop.d3d9SetTransform(D3DTRANSFORMSTATETYPE.D3DTS_VIEW, mat_identity);
				afxInterop.d3d9SetTransform(D3DTRANSFORMSTATETYPE.D3DTS_PROJECTION, mat_projection);
			}
			
			// Render:
			{
				// TODO: Consider to add and use afxInterop.d3d9DrawPrimitiveUP instead.
			
				var drawingData = afxInterop.createDrawingData(4 * (4*3+4*2));
				var dv = new DataView(drawingData.buffer);
				
				dv.setFloat32( 0*4, 0, true);
				dv.setFloat32( 1*4, height, true);
				dv.setFloat32( 2*4, 0, true);
				dv.setFloat32( 3*4, x0, true);
				dv.setFloat32( 4*4, y0, true);
				
				dv.setFloat32( 5*4, 0, true);
				dv.setFloat32( 6*4, 0, true);
				dv.setFloat32( 7*4, 0, true);
				dv.setFloat32( 8*4, x0, true);
				dv.setFloat32( 9*4, y1, true);
				
				dv.setFloat32(10*4, width, true);
				dv.setFloat32(11*4, height, true);
				dv.setFloat32(12*4, 0, true);
				dv.setFloat32(13*4, x1, true);
				dv.setFloat32(14*4, y0, true);
				
				dv.setFloat32(15*4, width, true);
				dv.setFloat32(16*4, 0, true);
				dv.setFloat32(17*4, 0, true);
				dv.setFloat32(18*4, x1, true);
				dv.setFloat32(19*4, y1, true);
				
				var vertexBuffer = afxInterop.d3d9CreateVertexBuffer(4, D3DUSAGE.D3DUSAGE_WRITEONLY, 0, D3DPOOL.D3DPOOL_DEFAULT, null);
				
				afxInterop.d3d9SetStreamSource(0, vertexBuffer, 0, 20);
				
				afxInterop.d3d9DrawPrimitive(D3DPRIMITIVETYPE.D3DPT_TRIANGLESTRIP, 0, 2);
				
				vertexBuffer.release();
			}
			
			afxInterop.endCleanState();
		}
		
		var cefTextureHandle = afxInterop.createCefWindowTextureSharedHandle();
		var cefTexture = null;
		
		///////////////////////////////
		
		afxInterop.onDeviceReset(function(){
			
			console.log("afxInterop.onDeviceReset");
			
			afxDeviceReset = true;
		});
		
		afxInterop.onNewConnection(function(){
		
			console.log("afxInterop.onNewConnection");
		
			afxNewConnection = true;
		
			afxInterop.scheduleCommand("echo cefhud: afxInterop.onNewConnection (connect / reconnect).");
			
			if(firstConnection) {
				firstConnection = false;
				afxInterop.scheduleCommand("echo afx_interop send cefhud - To send commands to me.");
			}
		});
		
		afxInterop.onCommands(function(commands){
		
			for(var i=0; i < commands.length; ++i)
			{
				var command = commands[i];
				if(0 < command.length)
				{
					if(2 <= command.length && "cefhud" === command[1])
					{
						if(3 <= command.length)
						{
							var handled = false;
							var command2 = command[2];
							switch(command2)
							{
							case "echo":
								var result = "echo";
								for(var j=3; j < command.length; ++j)
								{
									result += " "+command[j];
								}
								afxInterop.scheduleCommand(result);
								handled = true;
								break;
							case "reload":
								reload = true;
								handled = true;
								break;
							}
							
							if(handled) continue;
						}
						afxInterop.scheduleCommand("echo \""+command[0]+" cefhud echo <sText>+ - echo text back to CS:GO.\"");
						afxInterop.scheduleCommand("echo \""+command[0]+" cefhud reload - Reload current page.\"");
					}
				}
			}
		});
		
		// afxInterop.onViewOverride(function(value){

			// console.log( "afxInterop.onViewOverride: x: "+value.tX+", y: "+value.tY+", z: "+value.tZ+", rX: "+value.rX,+", rY: "+value.rY+", rZ: "+value.rZ+", fov: "+value.fov );
		
			// Uncomment return and those you want to override to set to a new value:			
			//return {
			//	tX: 0,
			//	tY: 0,
			//	tZ: 0,
			//	rX: 0,
			//	rY: 0,
			//	rZ: 0,
			//	fov: 90
			//};
		// });
		
		afxInterop.onRenderViewBegin(function(renderInfo){
		
			afxInterop.drawingConnect();
			
			var oldTexWidth = null;
			var oldTexHeight = null;
			
			if(afxRenderInfo)
			{
				oldTexWidth = afxRenderInfo.view.width - afxRenderInfo.view.x;
				oldTexHeight = afxRenderInfo.view.height - afxRenderInfo.view.y;
			}
			
			
			afxRenderInfo = renderInfo;
			afxPass = 0;
			
			var texWidth = afxRenderInfo.view.width - afxRenderInfo.view.x;
			var texHeight = afxRenderInfo.view.height - afxRenderInfo.view.y;			
			
			var passes = {};
			
			// Select passes you want here:
			// Hint: It is recommend to do one browser per one pass!
			
			//passes["beforeTranslucentShadow"] = true;
			//passes["afterTranslucentShadow"] = true;
			//passes["beforeTranslucent"] = true;
			//passes["afterTranslucent"] = true;
			//passes["beforeHud"] = true;
			passes["afterHud"] = true;
			//passes["afterRenderView"] = true;
			
			afxInterop.drawingPumpBegin(afxRenderInfo.frameCount, afxPass++);
			
			if (afxNewConnection || afxDeviceReset)
			{
				afxNewConnection = false;
				afxDeviceReset = false;
				
				console.log("Recreating D3D9 resources ...");
			
				// We are re-creating all resources on device reset and not only pooled ones, because we have no way of telling if the non-pooled ones were created successfully:
				
				if(shaders["afx_drawtexture_ps20"]) shaders["afx_drawtexture_ps20"].release();
				shaders["afx_drawtexture_ps20"] = afxInterop.d3d9CreatePixelShader(shaderData["afx_drawtexture_ps20.acs"]);
				
				if(vertexDeclarations["pos3_uv2"]) vertexDeclarations["pos3_uv2"].release();
				vertexDeclarations["pos3_uv2"] = afxInterop.d3d9CreateVertexDeclaration(vertexElements["pos3_uv2"]);
				
			}
			
			if(cefTexture && (afxNewConnection || afxDeviceReset || (oldTexWidth != texWidth || oldTexHeight != texHeight))) {
				cefTexture.release();
				cefTexture = null;
			}
			if(null === cefTexture) cefTexture = afxInterop.d3d9CreateTexture(texWidth, texHeight, 1, D3DUSAGE.D3DUSAGE_RENDERTARGET, 21, D3DPOOL.D3DPOOL_DEFAULT, cefTextureHandle);
			
			afxInterop.drawingPumpEnd();
			
			return passes;
		});
		
		/*
		afxInterop.onRenderPass(function(renderPassState, renderView){
			
			afxInterop.drawingPumpBegin(afxRenderInfo.frameCount, afxPass++);
			
			var texWidth = renderView.width - afxRenderInfo.renderView.x;
			var texHeight = renderView.height - afxRenderInfo.renderView.y;

			if(renderPassState == AFX_RENDERPASS_STATE.BeforeTranslucent)
			{
				
			}
			
			afxInterop.drawingPumpEnd();
		});
		*/
		
		afxInterop.onHudEnd(function(){
			afxInterop.drawingPumpBegin(afxRenderInfo.frameCount, afxPass++);
			
			var texWidth = afxRenderInfo.view.width - afxRenderInfo.view.x;
			var texHeight = afxRenderInfo.view.height - afxRenderInfo.view.y;
			
			afxInterop.drawingBeginFrame(texWidth, texHeight);
			
			drawRect2d(cefTexture, afxRenderInfo.view.x, afxRenderInfo.view.y, afxRenderInfo.view.width, afxRenderInfo.view.height, 0, 0, 1, 1);
			
			afxInterop.drawingPumpEnd();
		});
		
		
		// GameEvents:
		//
		// https://wiki.alliedmods.net/Counter-Strike:_Global_Offensive_Event
		
		afxInterop.gameEventSetTransmitClientTime(true);
		afxInterop.gameEventSetTransmitTick(true);
		
		var useridEnrichtments = AFX_GAMEVENT_ENRICHMENTS.UserIdWithSteamId
			| AFX_GAMEVENT_ENRICHMENTS.UseridWithEyePosition
			| AFX_GAMEVENT_ENRICHMENTS.UseridWithEyeAngels;
			
		var entNumEnrichments = AFX_GAMEVENT_ENRICHMENTS.EntnumWithOrigin
			| AFX_GAMEVENT_ENRICHMENTS.EntnumWithAngles;
		
		afxInterop.gameEventSetEnrichment('player_death', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('player_death', 'attacker', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('player_death', 'assister', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('other_death', 'attacker', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('player_hurt', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('player_hurt', 'attacker', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('item_purchase', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('bomb_beginplant', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('bomb_abortplant', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('bomb_planted', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('bomb_defused', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('bomb_exploded', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('bomb_pickup', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('bomb_dropped', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('bomb_dropped', 'entindex', entNumEnrichments);
		afxInterop.gameEventSetEnrichment('defuser_dropped', 'entityid', entNumEnrichments);
		afxInterop.gameEventSetEnrichment('defuser_pickup', 'entityid', entNumEnrichments);
		afxInterop.gameEventSetEnrichment('defuser_pickup', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('bomb_begindefuse', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('bomb_abortdefuse', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('hostage_follows', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('hostage_follows', 'hostage', entNumEnrichments);
		afxInterop.gameEventSetEnrichment('hostage_hurt', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('hostage_hurt', 'hostage', entNumEnrichments);
		afxInterop.gameEventSetEnrichment('hostage_killed', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('hostage_killed', 'hostage', entNumEnrichments);
		afxInterop.gameEventSetEnrichment('hostage_rescued', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('hostage_rescued', 'hostage', entNumEnrichments);
		afxInterop.gameEventSetEnrichment('hostage_stops_following', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('hostage_stops_following', 'hostage', entNumEnrichments);
		afxInterop.gameEventSetEnrichment('hostage_call_for_help', 'hostage', entNumEnrichments);
		afxInterop.gameEventSetEnrichment('vip_escaped', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('player_radio', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('bomb_beep', 'entindex', entNumEnrichments);
		afxInterop.gameEventSetEnrichment('weapon_fire', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('weapon_fire_on_empty', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('grenade_thrown', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('weapon_outofammo', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('weapon_reload', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('weapon_zoom', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('silencer_detach', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('inspect_weapon', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('weapon_zoom_rifle', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('player_spawned', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('item_pickup', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('item_pickup_failed', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('item_remove', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('ammo_pickup', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('ammo_pickup', 'index', entNumEnrichments);
		afxInterop.gameEventSetEnrichment('item_equip', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('enter_buyzone', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('exit_buyzone', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('enter_bombzone', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('exit_bombzone', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('enter_rescue_zone', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('exit_rescue_zone', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('silencer_off', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('silencer_on', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('buymenu_open', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('buymenu_close', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('round_end', 'winner', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('grenade_bounce', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('hegrenade_detonate', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('flashbang_detonate', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('smokegrenade_detonate', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('smokegrenade_expired', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('molotov_detonate', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('decoy_detonate', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('decoy_started', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('tagrenade_detonate', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('decoy_firing', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('bullet_impact', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('player_footstep', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('player_jump', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('player_blind', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('player_blind', 'entityid', entNumEnrichments);
		afxInterop.gameEventSetEnrichment('player_falldamage', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('door_moving', 'entityid', entNumEnrichments);
		afxInterop.gameEventSetEnrichment('door_moving', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('spec_target_updated', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('player_avenged_teammate', 'avenger_id', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('player_avenged_teammate', 'avenged_player_id', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('round_mvp', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('player_decal', 'userid', useridEnrichtments);
		// ... left out the gg / gungame, feel free to add it ...
		afxInterop.gameEventSetEnrichment('player_reset_vote', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('start_vote', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('player_given_c4', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('player_become_ghost', 'userid', useridEnrichtments);
		// ... left out the tr, feel free to add it ...
		afxInterop.gameEventSetEnrichment('jointeam_failed', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('teamchange_pending', 'userid', useridEnrichtments);
		afxInterop.gameEventSetEnrichment('ammo_refill', 'userid', useridEnrichtments);
		// ... left out the dangerzone, feel free to add it ...
		afxInterop.gameEventSetEnrichment('weaponhud_selection', 'userid', useridEnrichtments);
		
		afxInterop.onGameEvent(function(e){
			var docP = document.createElement('p');
			docP.appendChild(document.createTextNode(JSON.stringify(e)));
			divGameEvents.insertBefore(docP, divGameEvents.firstElementChild);
			//console.log(JSON.stringify(e));
		});
		
		//
		
		console.log(afxInterop.pipeName);
		
		// The worker function:

		setInterval(function(){
			if(reload)
			{
				reload = false;
				window.location.reload();
				console.log("windown.location.reload()");
			}
		
			if(afxInterop.connect())
			{
				if(afxInterop.getConnected())
				{
					while(divGameEvents.childNodes.length > 10) divGameEvents.lastElementChild.remove();
				}
				else
				{
					afxInterop.drawingConnect();
				}
			}
		},0 );
	}
</script>
</html>