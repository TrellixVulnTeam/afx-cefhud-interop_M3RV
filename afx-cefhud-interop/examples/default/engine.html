<!DOCTYPE html>
<html>
<body>
<script type="text/javascript" src="common.js"></script>
<script>

var AFX_GAMEVENT_ENRICHMENTS = {
	UserIdWithSteamId: (1 << 0),
	EntnumWithOrigin: (1 << 1),
	EntnumWithAngles: (1 << 2),
	UseridWithEyePosition: (1 << 3),
	UseridWithEyeAngels: (1<<4)
};

var AFX_GAMEVENT_TYPES = {
	Local: 0,
	CString: 1,
	Float: 2,
	Long: 3,
	Short: 4,
	Byte: 5,
	Bool: 6,
	Uint64: 7
}

var AFX_RENDERPASS_STATE = {
	BeforeTranslucentShadow: 2,
	AfterTranslucentShadow: 3,
	BeforeTranslucent: 4,
	AfterTranslucent: 5
};

////////////////////////////////////////////////////////////////////////////////

function AfxEngineInterop(interop, args) {
	
	var self = this;
	
	interop.setPipeName(args.pipeName);
	
	this.interop = interop;
	this.args = args;
	this.firstConnection = true;
	this.connected = 0;
	this.drawingConnected = 0;
	this.taskQueue = [];
	this.taskQueueDeferred = 0;	
	
	this.messageHandlers = {
		"drawingConnected": function(senderId) {
			if(self.drawingConnected) return;

			console.log("drawingConnected: "+senderId);
			++self.drawingConnected;

			self.deferTasks();
			toPromise(self.interop.connect).then((connected)=>{
				self.undeferTasks();
				if(self.connected && self.drawingConnected)
				{
					self.interop.pump(self.pumpEvents);
				}
			}).catch((error)=>{
				logError(error);
				self.disconnect(true);
			});
		},
		"drawingDisconnected": function(senderId) {
			if(!self.drawingConnected) return;

			console.log("drawingDisconnected: "+senderId);
			--self.drawingConnected;

			if(self.connected)
			{
				self.disconnect(true);
			}
		},
		"drawingConnecting": function(senderId) {
			toPromise(self.interop.sendMessage, self.args.drawingInteropId, JSON.stringify({
				"id": "connect",
				"args": [self.interop.id]
			})).catch((e)=>{
				logError(e);
			});
		},
	};
	
	interop.onMessage = function(senderId, message){
		self.queueTask(function() {
			self.onMessage(senderId, message);
		})
	};
	
	// GameEvents:
	//
	// https://wiki.alliedmods.net/Counter-Strike:_Global_Offensive_Event

	interop.gameEventSetTransmitClientTime(true);
	interop.gameEventSetTransmitTick(true);
	
	var useridEnrichtments = AFX_GAMEVENT_ENRICHMENTS.UserIdWithSteamId
		| AFX_GAMEVENT_ENRICHMENTS.UseridWithEyePosition
		| AFX_GAMEVENT_ENRICHMENTS.UseridWithEyeAngels;
		
	var entNumEnrichments = AFX_GAMEVENT_ENRICHMENTS.EntnumWithOrigin
		| AFX_GAMEVENT_ENRICHMENTS.EntnumWithAngles;
	
	interop.gameEventSetEnrichment('player_death', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('player_death', 'attacker', useridEnrichtments);
	interop.gameEventSetEnrichment('player_death', 'assister', useridEnrichtments);
	interop.gameEventSetEnrichment('other_death', 'attacker', useridEnrichtments);
	interop.gameEventSetEnrichment('player_hurt', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('player_hurt', 'attacker', useridEnrichtments);
	interop.gameEventSetEnrichment('item_purchase', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('bomb_beginplant', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('bomb_abortplant', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('bomb_planted', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('bomb_defused', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('bomb_exploded', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('bomb_pickup', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('bomb_dropped', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('bomb_dropped', 'entindex', entNumEnrichments);
	interop.gameEventSetEnrichment('defuser_dropped', 'entityid', entNumEnrichments);
	interop.gameEventSetEnrichment('defuser_pickup', 'entityid', entNumEnrichments);
	interop.gameEventSetEnrichment('defuser_pickup', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('bomb_begindefuse', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('bomb_abortdefuse', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('hostage_follows', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('hostage_follows', 'hostage', entNumEnrichments);
	interop.gameEventSetEnrichment('hostage_hurt', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('hostage_hurt', 'hostage', entNumEnrichments);
	interop.gameEventSetEnrichment('hostage_killed', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('hostage_killed', 'hostage', entNumEnrichments);
	interop.gameEventSetEnrichment('hostage_rescued', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('hostage_rescued', 'hostage', entNumEnrichments);
	interop.gameEventSetEnrichment('hostage_stops_following', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('hostage_stops_following', 'hostage', entNumEnrichments);
	interop.gameEventSetEnrichment('hostage_call_for_help', 'hostage', entNumEnrichments);
	interop.gameEventSetEnrichment('vip_escaped', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('player_radio', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('bomb_beep', 'entindex', entNumEnrichments);
	interop.gameEventSetEnrichment('weapon_fire', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('weapon_fire_on_empty', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('grenade_thrown', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('weapon_outofammo', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('weapon_reload', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('weapon_zoom', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('silencer_detach', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('inspect_weapon', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('weapon_zoom_rifle', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('player_spawned', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('item_pickup', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('item_pickup_failed', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('item_remove', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('ammo_pickup', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('ammo_pickup', 'index', entNumEnrichments);
	interop.gameEventSetEnrichment('item_equip', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('enter_buyzone', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('exit_buyzone', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('enter_bombzone', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('exit_bombzone', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('enter_rescue_zone', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('exit_rescue_zone', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('silencer_off', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('silencer_on', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('buymenu_open', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('buymenu_close', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('round_end', 'winner', useridEnrichtments);
	interop.gameEventSetEnrichment('grenade_bounce', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('hegrenade_detonate', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('flashbang_detonate', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('smokegrenade_detonate', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('smokegrenade_expired', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('molotov_detonate', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('decoy_detonate', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('decoy_started', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('tagrenade_detonate', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('decoy_firing', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('bullet_impact', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('player_footstep', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('player_jump', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('player_blind', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('player_blind', 'entityid', entNumEnrichments);
	interop.gameEventSetEnrichment('player_falldamage', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('door_moving', 'entityid', entNumEnrichments);
	interop.gameEventSetEnrichment('door_moving', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('spec_target_updated', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('player_avenged_teammate', 'avenger_id', useridEnrichtments);
	interop.gameEventSetEnrichment('player_avenged_teammate', 'avenged_player_id', useridEnrichtments);
	interop.gameEventSetEnrichment('round_mvp', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('player_decal', 'userid', useridEnrichtments);
	// ... left out the gg / gungame, feel free to add it ...
	interop.gameEventSetEnrichment('player_reset_vote', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('start_vote', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('player_given_c4', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('player_become_ghost', 'userid', useridEnrichtments);
	// ... left out the tr, feel free to add it ...
	interop.gameEventSetEnrichment('jointeam_failed', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('teamchange_pending', 'userid', useridEnrichtments);
	interop.gameEventSetEnrichment('ammo_refill', 'userid', useridEnrichtments);
	// ... left out the dangerzone, feel free to add it ...
	interop.gameEventSetEnrichment('weaponhud_selection', 'userid', useridEnrichtments);
	
	//

	this.pumpEvents = {
		// optional.
		"onNewConnection": function(){
			console.log("New connection");
			self.interop.pump(self.pumpEvents);
		},
		// recommended.
		"onDone": function(){
			self.interop.pump(self.pumpEvents);
		},
		// recommended.
		"onError": function(error){
			console.log("pump onError: "+error);
			self.disconnect(true);
		},
		// optional.
		"onCommands": function(commands) {
		
			var doCommands = [];
		
			if(self.firstConnection) {
				self.firstConnection = false;
				doCommands.push("echo afx_interop send cefhud - To send commands to me.");
			}
			
			for(var i=0; i < commands.length; ++i)
			{
				var command = commands[i];
				if(0 < command.length)
				{
					if(2 <= command.length && "cefhud" === command[1])
					{
						if(3 <= command.length)
						{
							var handled = false;
							var command2 = command[2];
							switch(command2)
							{
							case "echo":
								var result = "echo";
								for(var j=3; j < command.length; ++j)
								{
									result += " "+command[j];
								}
								doCommands.push(result);
								handled = true;
								break;
							}
							
							if(handled) continue;
						}
						doCommands.push("echo \""+command[0]+" cefhud echo <sText>+ - echo text back to CS:GO.\"");
					}
				}
			}
			self.interop.pump(self.pumpEvents, doCommands);
		},
		// optional.
		"onGameEvent": function(e){
			toPromise(self.interop.sendMessage, self.args.drawingInteropId, JSON.stringify({
				"id": "onGameEvent",
				"args": [e]
			})).catch((e)=>{
				logError(e);
			});
			self.interop.pump(self.pumpEvents);
		},
		// optional.
		"onRenderViewBegin": function(renderInfo) {
	
			self.renderInfo = renderInfo;
			self.pass = 0;
			
			toPromise(self.interop.sendMessage, self.args.drawingInteropId, JSON.stringify({
				"id": "onRenderViewBegin",
				"args": [renderInfo]
			})).catch((e)=>{
				logError(e);
			});
			self.interop.pump(self.pumpEvents);
		},
		/*
		// optional.
		"onRenderViewBeforeTranslucent" : function(view) {
			self.interop.pump(self.pumpEvents);
		},*/
		/*
		// optional.
		"onRenderViewAfterTranslucent" : function(view) {
			self.interop.pump(self.pumpEvents);
		},*/
		/*
		// optional.
		"onRenderViewBeforeTranslucentShadow" : function(view) {
			self.interop.pump(self.pumpEvents);
		},*/
		/*
		// optional.
		"onRenderViewAfterTranslucentShadow" : function(view) {
			self.interop.pump(self.pumpEvents);
		},*/
		/*
		// optional.
		"onRenderViewHudBegin" : function() {
			self.interop.pump(self.pumpEvents);
		},*/
		// optional.
		"onRenderViewHudEnd": function(){
			console.log("onHudEnd");
			toPromise(self.interop.sendMessage, self.args.drawingInteropId, JSON.stringify({
				"id": "onHudEnd",
				"args": [self.renderInfo.frameCount , self.pass]
			})).catch((e)=>{
				logError(e);
			});
			self.pass++;
			self.interop.pump(self.pumpEvents);
		},
		// optional.
		//"onRenderViewEnd": function() {
		//	self.interop.pump(self.pumpEvents);
		//},
		/*
		// optional.
		"onViewOverride": function(view) {
			self.interop.pump(self.pumpEvents, {
				//tX: 0,
				//tY: 0,
				//tZ: 0,
				//rX: 0,
				//rY: 0,
				//rZ: 0,
				//fov: 90,
			});
		},*/
	};
	
	toPromise(self.interop.sendMessage, this.args.indexInteropId, JSON.stringify({
		"id": "engineCreated",
		"args": [self.interop.id]
	})).catch((e)=>{
		logError(e);
	});

	this.connect();
}

AfxEngineInterop.prototype.onMessage = function(senderId, message) {
	const args = JSON.parse(message);
	this.messageHandlers[args.id].apply(this, args.args);
}
////////////////////////////////////////////////////////////////////////////////


AfxEngineInterop.prototype.queueTask = function(task) {
	
	if(Array.isArray(task))
	{
		for(var i = 0; i < task.length; ++i)
			this.queueTask(tasks[i]);
		return;
	}
	
	if(0 == this.taskQueueDeferred)
	{
		task();
		return;
	}
	
	this.taskQueue.push(task);
}

AfxEngineInterop.prototype.stackTask = function(task) {
	
	if(Array.isArray(task))
	{
		for(var i = 0; i < task.length; ++i)
			this.stackTask(tasks[i]);
		return;
	}
	
	if(0 == this.taskQueueDeferred)
	{
		task();
		return;
	}
	
	this.taskQueue.unshift(task);
}

AfxEngineInterop.prototype.deferTasks = function() {
	++this.taskQueueDeferred;
}

AfxEngineInterop.prototype.undeferTasks = function() {
	--this.taskQueueDeferred;

	var self = this;
	
	function runTasks() {
		self.taskQueue.shift()();
		if(self.taskQueueDeferred === 0 && 0 < self.taskQueue.length)
		{
			queueMicrotask(runTasks);
		}
	}
	
	if(self.taskQueueDeferred === 0 && 0 < self.taskQueue.length)
	{
		queueMicrotask(runTasks);
	}
}

AfxEngineInterop.prototype.connect = function() {

	var self = this;

	if(self.connected) return;
	
	self.deferTasks();

	self.interop.connect(function(connected){
	
		if(connected)
		{
			++self.connected;

			toPromise(self.interop.sendMessage, self.args.drawingInteropId, JSON.stringify({
				"id": "connect",
				"args": [self.interop.id]
			})).catch((e)=>{
				logError(e);
			});

			self.undeferTasks();
		}
		else {
			self.undeferTasks();

			if(self.connected) return;

			queueMicrotask(function(){
				self.connect();
			});
		}

	}, function(){
	
		console.log("connect failed");
		
		self.disconnect(true);
	});
}

AfxEngineInterop.prototype.disconnect = function(purge) {

	var self = this;

	if(!self.connected) return;

	if(self.drawingConnected) {
		toPromise(self.interop.sendMessage, self.args.drawingInteropId, JSON.stringify({
			"id": "disconnect",
			"args": [self.interop.id]
		})).catch((e)=>{
			logError(e);
		});
		
		return;
	}

	self.deferTasks();
	
	toPromise(self.interop.close).finally(() => {

		if(purge)
		{
			self.taskQueue = [];
			self.taskQueueDeferred = 1;
		}
		--self.connected;
		self.undeferTasks();

		if(self.connected) return;

		// retry in a second.
		
		setTimeout(function(){
			self.connect();
		}, 1000);
	});
}

////////////////////////////////////////////////////////////////////////////////

window.afxInterop.init(function(interop, message){
	console.log("new AfxEngineInterop: "+message); 
	new AfxEngineInterop(interop, JSON.parse(message));
});

</script>
</body>
</html>