<!DOCTYPE html>
<html>
<style>

html {
	overflow: hidden;
}

html,body,div {
  margin: 0;
  padding: 0;
}

.main {
	margin: 1.5rem;
	padding: 1.5rem;
	color: #fff;
	backdrop-filter: hue-rotate(120deg);
}
.indicator {
	float: right;
	width: 3rem;
	height: 3rem;
	border: 3px solid red;
	background: #000;
}
.indicator.white {
	background: #fff;
}
</style>

<body>
<div id="indicator" class="indicator"></div>
<div id="indicator2" class="indicator"></div>
<div class="main">
<h1 style="color: #00ff00">Hello World from afx-cefhud-interop</h1>
<p>Client time: <span id="clientTime"></span></p>
<h2>Last game events:</h2>
<div id="gameEvents" style="border:1px solid #fff; font-size: 12px; font-family: monospace"></div>
</div>
<div style="clear: both"></div>
<script type="module">

import * as Utils from '../../js/modules/utils.js';
import * as Windows from '../../js/modules/windows.js';
import * as D3d9 from '../../js/modules/d3d9.js';

////////////////////////////////////////////////////////////////////////////////

function AfxDrawingInterop(interop,args) {
	
	var self = this;
	
	interop.setPipeName(args.pipeName);
	
	this.interop = interop;
	this.args = args;
	
	this.cefTextureHandle = null;
	this.cefTextures =  {};
	this.elIndicator = document.getElementById('indicator');
	this.elIndicator2 = document.getElementById('indicator2');
	this.divGameEvents = document.getElementById('gameEvents');
	this.elClientTime = document.getElementById('clientTime');
	
	this.engineInteropId = null;

	this.connected = false;
	this.messagePromises = {};

	this.renderQueue = [];
	this.firstRender = true;

	this.shaderData = {
		"afx_drawtexture_vs20": this.compileShader(this.stringToAfxData(`
			matrix World;
			matrix View;
			matrix Projection;

			struct VS_INPUT
			{
				float3 pos : POSITION;
				float2 t0 : TEXCOORD0;
			};
			
			struct VS_OUTPUT
			{
				float4 pos : POSITION;
				float4 c : COLOR;
				float2 t0 : TEXCOORD0;
			};

			VS_OUTPUT main( const VS_INPUT i )
			{
				VS_OUTPUT o;
				
				o.pos = float4(i.pos, 1);
				o.pos = mul( o.pos, World );
    			o.pos = mul( o.pos, View );
    			o.pos = mul( o.pos, Projection );	
				o.pos /= o.pos.w;			
				o.c = float4(o.pos.x,0,o.pos.y,1);
				o.t0 = i.t0;
				
				return o;
			}
		`), null, null, null, "main", "vs_2_0", 0, 0, 0, null),
		"afx_drawtexture_ps20": this.compileShader(this.stringToAfxData(`
			sampler g_sTextureSampler : register( s0 );

			struct PS_INPUT
			{
				float2 t0 : TEXCOORD0;
			};

			float4 main( const PS_INPUT i ) : COLOR
			{
				return tex2D(g_sTextureSampler, i.t0);
			}
		`), null, null, null, "main", "ps_2_0", 0, 0, 0, null),
	};
	
	this.shaders = {
		"afx_drawtexture_vs20": null,
		"afx_drawtexture_ps20": null,
	};
	
	this.messageHandlers = {
		"connect": async function(senderId) {
			this.engineInteropId = senderId;
			await this.connect(senderId);
		},
		"disconnect": async function(senderId) {
			await Utils.toPromise(this, "disconnect");
		},
		"onRenderViewBegin": async function(renderInfo){

			this.elIndicator2.classList.toggle("white");

			var width = renderInfo.view.width - renderInfo.view.x;
			var height = renderInfo.view.height - renderInfo.view.y;

			if(this.width !== width || this.height !== height)
			{
				await Utils.toPromise(self.interop, "setSize", width, height);
			}
	
			this.width = width;
			this.height = height;
			this.renderInfo = renderInfo;
			this.elClientTime.innerText = renderInfo.curTime;
		},
		"onGameEvent": async function(e){
			while(this.divGameEvents.childNodes.length > 10) this.divGameEvents.lastElementChild.remove();

			var docP = document.createElement('p');
			docP.appendChild(document.createTextNode(JSON.stringify(e)));
			this.divGameEvents.insertBefore(docP, this.divGameEvents.firstElementChild);
		},
		"onHudEnd": async function(frameCount, pass){

			this.elIndicator.classList.toggle("white",(frameCount % 2) == 0);

			async function doRender(cefTextureHandle,frameCount, pass, width, height, renderInfo){
				var inFlow = await Utils.toPromise(self.interop, "pumpBegin", frameCount, pass);

				if(!inFlow) {
					Utils.logError("out of flow");
					return;
				}

				try {
					if(cefTextureHandle.invalid) throw toSoftError(new Error("cefTextureHandle.invalid"));

					var cefTexture = self.getCefTexture(cefTextureHandle);
				
					if(null === self.shaders["afx_drawtexture_vs20"]) {
						var refVertexShader = [undefined];
						var hr = await Utils.toPromise(self.interop, "d3d9CreateVertexShader", self.shaderData["afx_drawtexture_vs20"], refVertexShader);
						if(Utils.FAILED(hr)) throw toSoftError(Utils.failedHResultToError(hr));
						self.shaders["afx_drawtexture_vs20"] = refVertexShader[0];
					}
					
					if(null === self.shaders["afx_drawtexture_ps20"]) {
						var refPixelShader = [undefined];
						var hr = await Utils.toPromise(self.interop, "d3d9CreatePixelShader", self.shaderData["afx_drawtexture_ps20"], refPixelShader);
						if(Utils.FAILED(hr)) throw toSoftError(Utils.failedHResultToError(hr));
						self.shaders["afx_drawtexture_ps20"] = refPixelShader[0];
					}
					
					if(null === self.vertexDeclarations["pos3_uv2"]) {
						var refVertexDeclaration = [undefined];
						var hr = await Utils.toPromise(self.interop, "d3d9CreateVertexDeclaration", self.vertexElements["pos3_uv2"], refVertexDeclaration);
						if(Utils.FAILED(hr)) throw toSoftError(Utils.failedHResultToError(hr));
						self.vertexDeclarations["pos3_uv2"] = refVertexDeclaration[0];
					}

					if(!cefTexture) {
						var refTexture = [undefined];
						const D3DFMT_A8R8G8B8 = 21;
						var hr = await Utils.toPromise(self.interop, "d3d9CreateTexture", width, height, 1, D3d9.D3DUSAGE.D3DUSAGE_RENDERTARGET, D3DFMT_A8R8G8B8, D3d9.D3DPOOL.D3DPOOL_DEFAULT, refTexture, [cefTextureHandle]);
						if(Utils.FAILED(hr)) throw toSoftError(Utils.failedHResultToError(hr, "CreateTexture failed for cefTextureHandle: ("+cefTextureHandle.hi+", "+cefTextureHandle.lo+")"));

						cefTexture = refTexture[0];

						console.log("New texture for cefTextureHandle: ("+cefTextureHandle.hi+", "+cefTextureHandle.lo+")");
						self.setCefTexture(cefTextureHandle, cefTexture);
					}

					await self.drawRect2d(cefTexture, renderInfo.view.x, renderInfo.view.y, renderInfo.view.width, renderInfo.view.height, 0, 0, 1, 1);
					await Utils.toPromise(self.interop, "waitForClientGpu");
				}
				catch(error) {
					if(error && error.soft)
					{
						Utils.logError(error);
					}
					else throw error;
				}

				await Utils.toPromise(self.interop, "pumpEnd");
			}

			await new Promise((resolve,reject)=>{
				self.renderQueue.push(function(cefTextureHandle){
					doRender(cefTextureHandle, frameCount, pass, self.width, self.height, self.renderInfo).then(()=>{
						resolve();
					}).catch((e)=>{
						reject(e);
					});
				});
				
				async function render() {
					await Utils.toPromise(self.interop, "sendExternalBeginFrame");
					if(self.firstRender) {
						// This is utterly neccessary to unstuck the CEF rendering queue initially:
						self.firstRender = false;
						for(var i=0; i < 25; ++i) await Utils.toPromise(self.interop, "sendExternalBeginFrame");
					}
				}

				render().then(()=>{});
			});
		}
	};
	
	interop.onMessage = function(senderId, message){
		
		const jMessage = JSON.parse(message);
		
		async function processMessage(jMessage)
		{
			try {
				await self.messageHandlers[jMessage.id].apply(self, jMessage.args);
			}
			catch(e) {
				Utils.logError(e);
				if(!(e && e.soft))
					await Utils.toPromise(self, "disconnect");
			}
		}
		
		function queueMessage(jMessage)
		{
			const port = jMessage.port || 0;
			
			var promise = self.messagePromises[port];
			if(undefined === promise) promise = Promise.resolve();
			
			self.messagePromises[port] = promise.finally(()=>processMessage(jMessage));
		}
		
		queueMessage(jMessage);
	}
	
	interop.onDeviceReset = function(){
		self.onDeviceReset().catch((e)=>{
			Utils.logError(e);
			if(!(e && e.soft))
				return Utils.toPromise(self, "disconnect");
		});
	};

	interop.onAcceleratedPaint = function(cefTextureHandle){
		if(0 < self.renderQueue.length)
			self.renderQueue.shift()(cefTextureHandle);
	}

	interop.onReleaseShareHandle = function(cefTextureHandle){

		async function release(cefTextureHandle)
		{
			var cefTexture = self.getCefTexture(cefTextureHandle);
			if(cefTexture)
			{
				if(this.connected)
				{
					try {
						var hr = await Utils.toPromise(cefTexture, "release");
						if(Utils.FAILED(hr)) throw Utils.failedHResultToError(hr);
					}
					catch(e)
					{
						Utils.logError(e);
					}
				}

				self.removeCefTexture(cefTextureHandle);
			}
		}

		release(cefTextureHandle).catch((e)=>{
			Utils.logError(e);
			if(!(e && e.soft))
				return Utils.toPromise(self, "disconnect");
		});
	}

	this.vertexElements = {
		"pos3_uv2": this.buildD3d9VertexElements([
			{
				"stream": 0,
				"offset": 0,
				"type": D3d9.D3DDECLTYPE.D3DDECLTYPE_FLOAT3,
				"method": D3d9.D3DDECLMETHOD.D3DDECLMETHOD_DEFAULT,
				"usage": D3d9.D3DDECLUSAGE.D3DDECLUSAGE_POSITION, "usageIndex": 0
			},
			{
				"stream": 0,
				"offset": 3*4,
				"type": D3d9.D3DDECLTYPE.D3DDECLTYPE_FLOAT2,
				"method": D3d9.D3DDECLMETHOD.D3DDECLMETHOD_DEFAULT,
				"usage": D3d9.D3DDECLUSAGE.D3DDECLUSAGE_TEXCOORD, "usageIndex": 0
			},
		])
	};

	this.vertexDeclarations = {
		"pos3_uv2": null
	};

	this.vertexBuffers = {
		"rect": null
	}	

	Utils.toPromise(self.interop, "sendMessage", this.args.indexInteropId, JSON.stringify({
		"id": "drawingCreated",
		"args": [interop.id]
	}));
}

AfxDrawingInterop.prototype.onDeviceReset = async function() {
	
	// We currently re-create all resources, even non-pooled ones.
	// TODO: change the above.

	while(0 < this.cefTextures.length)
	{
		var hiKey = Object.keys(this.cefTextures)[0];
		var loKey = Object.keys(this.cefTextures[hiKey])[0];

		var cefTextureHandle = this.interop.createHandleFromLoHi(loKey,hiKey);

		var cefTexture = this.getCefTexture(cefTextureHandle);
		
		var hr = await Utils.toPromise(cefTexture, "release");
		if(Utils.FAILED(hr)) throw Utils.failedHResultToError(hr);

		this.removeCefTexture(cefTextureHandle);
	}
	
	if(this.shaders["afx_drawtexture_vs20"])
	{
		var hr = await Utils.toPromise(this.shaders["afx_drawtexture_vs20"], "release");
		if(Utils.FAILED(hr)) throw Utils.failedHResultToError(hr);
		this.shaders["afx_drawtexture_vs20"] = null;
	}
	if(this.shaders["afx_drawtexture_ps20"])
	{
		var hr = await Utils.toPromise(this.shaders["afx_drawtexture_ps20"], "release");
		if(Utils.FAILED(hr)) throw Utils.failedHResultToError(hr);
		this.shaders["afx_drawtexture_ps20"] = null;
	}
	if(this.vertexDeclarations["pos3_uv2"])
	{
		var hr = await Utils.toPromise(this.vertexDeclarations["pos3_uv2"], "release");
		if(Utils.FAILED(hr)) throw Utils.failedHResultToError(hr);
		this.vertexDeclarations["pos3_uv2"] = null;
	}
}

/**
 * @remarks NOT NULL TERMINATED!
 */
AfxDrawingInterop.prototype.stringToAfxData = function(value) {
	var dd = this.interop.createDrawingData(value.length);
	var dv = new DataView(dd);
	
	for(var i = 0; i < value.length; ++i)
	{
		dv.setUint8(i, value.charCodeAt(i));
	}
	
	return dd;
}

/**
 * @param includes MUST BE null.
 * @remarks https://docs.microsoft.com/en-us/windows/win32/api/d3dcompiler/nf-d3dcompiler-d3dcompile2
 */
AfxDrawingInterop.prototype.compileShader = function(srcData,sourceName,defines,includes,entryPoint,target,flags1,flags2,secondaryDataFlags,secondaryData) {
	
	var result = this.interop.d3dCompile2(
		srcData,
		sourceName,
		defines,
		includes,
		entryPoint,
		target,
		flags1,
		flags2,
		secondaryDataFlags,
		secondaryData
	);
	
	if(0 !== result.hResult)
	{	
		var errorStr = "[UNKNOWN]";
		if(null !== result.errorMsgs)
		{
			var decoder = new TextDecoder('utf-8', {fatal: true});
			var cefIsBuggy = new ArrayBuffer(result.errorMsgs.byteLength);
			var dvIn = new DataView(result.errorMsgs);
			var dvOut = new DataView(cefIsBuggy);
			for(var i = 0; i < cefIsBuggy.byteLength; ++i) dvOut.setUint8(i, dvIn.getUint8(i));
			errorStr = decoder.decode(cefIsBuggy);
		}
		throw errorStr;
	}
	
	return result.code;
}

AfxDrawingInterop.prototype.drawRect2d = async function(texture,x,y,width,height,x0,y0,x1,y1) {

	var self = this;
	
	// Orthographic projection matrix:
	const L = 0.5 + x;
	const R = 0.5 + x + width;
	const T = 0.5 + y;
	const B = 0.5 + y + height;
	const mat_identity = [
		1.0, 0.0, 0.0, 0.0,
		0.0, 1.0, 0.0, 0.0,
		0.0, 0.0, 1.0, 0.0,
		0.0, 0.0, 0.0, 1.0
	];
	const mat_projection = [
		2.0 / (R - L)    , 0.0              , 0.0, 0.0,
		0.0              , 2.0 / (T - B)    , 0.0, 0.0,
		0.0              , 0.0              , 0.5, 0.0,
		(L + R) / (L - R), (T + B) / (B - T), 0.5, 1.0
	];
	
	//
	var vertexStreamZeroData = this.interop.createDrawingData(4 * ((3+2)*4));
	{
		var dv = new DataView(vertexStreamZeroData);
		
		dv.setFloat32( 0*4, 0, true);
		dv.setFloat32( 1*4, height, true);
		dv.setFloat32( 2*4, 0, true);
		dv.setFloat32( 3*4, x0, true);
		dv.setFloat32( 4*4, y0, true);
		
		dv.setFloat32( 5*4, 0, true);
		dv.setFloat32( 6*4, 0, true);
		dv.setFloat32( 7*4, 0, true);
		dv.setFloat32( 8*4, x0, true);
		dv.setFloat32( 9*4, y1, true);
		
		dv.setFloat32(10*4, width, true);
		dv.setFloat32(11*4, height, true);
		dv.setFloat32(12*4, 0, true);
		dv.setFloat32(13*4, x1, true);
		dv.setFloat32(14*4, y0, true);
		
		dv.setFloat32(15*4, width, true);
		dv.setFloat32(16*4, 0, true);
		dv.setFloat32(17*4, 0, true);
		dv.setFloat32(18*4, x1, true);
		dv.setFloat32(19*4, y1, true);
	}
	
	//
	
	async function toSoftError(error) {
		error.soft = true;
		
		await Utils.toPromise(self.interop, "endCleanState");

		return error;
	}
	
	//

	await Utils.toPromise(self.interop, "beginCleanState");
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetVertexDeclaration", this.vertexDeclarations["pos3_uv2"]);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetViewport", {
				"x": x,
				"y": y,
				"width": width,	
				"height": height,
				"minZ": 0.0,
				"maxZ": 1.0
	});
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetRenderState", D3d9.D3DRENDERSTATETYPE.D3DRS_SRGBWRITEENABLE, Windows.BOOL.FALSE);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetRenderState", D3d9.D3DRENDERSTATETYPE.D3DRS_COLORWRITEENABLE, D3d9.D3DRS_COLORWRITEENABLE.D3DCOLORWRITEENABLE_ALPHA | D3d9.D3DRS_COLORWRITEENABLE.D3DCOLORWRITEENABLE_BLUE | D3d9.D3DRS_COLORWRITEENABLE.D3DCOLORWRITEENABLE_GREEN | D3d9.D3DRS_COLORWRITEENABLE.D3DCOLORWRITEENABLE_RED);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetRenderState", D3d9.D3DRENDERSTATETYPE.D3DRS_SEPARATEALPHABLENDENABLE, Windows.BOOL.FALSE);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetVertexShader", null);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetPixelShader", this.shaders["afx_drawtexture_ps20"]);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetRenderState", D3d9.D3DRENDERSTATETYPE.D3DRS_CULLMODE, D3d9.D3DCULL.D3DCULL_NONE);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetRenderState", D3d9.D3DRENDERSTATETYPE.D3DRS_ZWRITEENABLE, Windows.BOOL.FALSE);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetRenderState", D3d9.D3DRENDERSTATETYPE.D3DRS_ZFUNC, D3d9.D3DCMPFUNC.D3DCMP_ALWAYS);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetRenderState", D3d9.D3DRENDERSTATETYPE.D3DRS_ZENABLE, D3d9.D3DZBUFFERTYPE.D3DZB_FALSE);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetRenderState", D3d9.D3DRENDERSTATETYPE.D3DRS_ALPHABLENDENABLE, Windows.BOOL.TRUE);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetRenderState", D3d9.D3DRENDERSTATETYPE.D3DRS_ALPHATESTENABLE, Windows.BOOL.FALSE);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetRenderState", D3d9.D3DRENDERSTATETYPE.D3DRS_MULTISAMPLEANTIALIAS, Windows.BOOL.FALSE);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));

	var hr = await Utils.toPromise(self.interop, "d3d9SetRenderState", D3d9.D3DRENDERSTATETYPE.D3DRS_LIGHTING, Windows.BOOL.FALSE);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetRenderState", D3d9.D3DRENDERSTATETYPE.D3DRS_SRCBLEND, D3d9.D3DBLEND.D3DBLEND_SRCALPHA);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetRenderState", D3d9.D3DRENDERSTATETYPE.D3DRS_DESTBLEND, D3d9.D3DBLEND.D3DBLEND_INVSRCALPHA);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetRenderState", D3d9.D3DRENDERSTATETYPE.D3DRS_FILLMODE, D3d9.D3DFILLMODE.D3DFILL_SOLID);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetTextureStageState", 0, D3d9.D3DTEXTURESTAGESTATETYPE.D3DTSS_COLOROP, D3d9.D3DTEXTUREOP.D3DTOP_SELECTARG1);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetTextureStageState", 0, D3d9.D3DTEXTURESTAGESTATETYPE.D3DTSS_COLORARG1, D3d9.D3DTEXTUREARG.D3DTA_TEXTURE);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetTextureStageState", 0, D3d9.D3DTEXTURESTAGESTATETYPE.D3DTSS_ALPHAOP, D3d9.D3DTEXTUREOP.D3DTOP_SELECTARG1);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));

	var hr = await Utils.toPromise(self.interop, "d3d9SetTextureStageState", 0, D3d9.D3DTEXTURESTAGESTATETYPE.D3DTSS_ALPHAARG1, D3d9.D3DTEXTUREARG.D3DTA_TEXTURE);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetSamplerState", 0, D3d9.D3DSAMPLERSTATETYPE.D3DSAMP_MINFILTER, D3d9.D3DTEXTUREFILTERTYPE.D3DTEXF_LINEAR);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetSamplerState", 0, D3d9.D3DSAMPLERSTATETYPE.D3DSAMP_MAGFILTER, D3d9.D3DTEXTUREFILTERTYPE.D3DTEXF_LINEAR);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetSamplerState", 0, D3d9.D3DSAMPLERSTATETYPE.D3DSAMP_SRGBTEXTURE, Windows.BOOL.FALSE);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetTexture", 0, texture);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));

	var hr = await Utils.toPromise(self.interop, "d3d9SetTransform", D3d9.D3DTRANSFORMSTATETYPE.D3DTS_WORLD, mat_identity);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetTransform", D3d9.D3DTRANSFORMSTATETYPE.D3DTS_VIEW, mat_identity);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9SetTransform", D3d9.D3DTRANSFORMSTATETYPE.D3DTS_PROJECTION, mat_projection);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	var hr = await Utils.toPromise(self.interop, "d3d9DrawPrimitiveUP", D3d9.D3DPRIMITIVETYPE.D3DPT_TRIANGLESTRIP, 2, vertexStreamZeroData, 5*4);
	if(Utils.FAILED(hr)) throw await toSoftError(Utils.failedHResultToError(hr));
	
	await Utils.toPromise(self.interop, "endCleanState");
}


AfxDrawingInterop.prototype.buildD3d9VertexElements = function(definitions) {

	var dd = this.interop.createDrawingData(8 * (definitions.length + 1));
	var dv = new DataView(dd);
	var i = 0;
	for(; i < definitions.length; ++i)
	{
		var definition = definitions[i];
		dv.setUint16(i*8 +  0, definition["stream"],true);
		dv.setUint16(i*8 +  2, definition["offset"],true);
		dv.setUint8(i*8 +  4, definition["type"]);
		dv.setUint8(i*8 +  5, definition["method"]);
		dv.setUint8(i*8 +  6, definition["usage"]);
		dv.setUint8(i*8 +  7, definition["usageIndex"]);
	}
	
	// append D3DDECL_END:
	dv.setUint16(i*8 +  0, 0xff,true);
	dv.setUint16(i*8 +  2, 0,true);
	dv.setUint8(i*8 +  4, 17);
	dv.setUint8(i*8 +  5, 0);
	dv.setUint8(i*8 +  6, 0);
	dv.setUint8(i*8 +  7, 0);
	
	return dd;
}

AfxDrawingInterop.prototype.connect = async function() {

	this.connected = true;

	await Utils.toPromise(this.interop, "connect");

	await Utils.toPromise(this.interop, "sendMessage", this.args.indexInteropId, JSON.stringify({
		"id": "drawingConnected",
		"args": [this.interop.id]
	}));

	await Utils.toPromise(this.interop, "sendMessage", this.engineInteropId, JSON.stringify({
		"id": "drawingConnected",
		"args": [this.interop.id]
	}));
}

AfxDrawingInterop.prototype.disconnect = async function() {

	while(0 < this.renderQueue.length)
	{
		console.log("Waiting for renderer to finish before disconnecting ...");
		await Utils.sleepPromise(250);
	}
	
	this.interop.cancel();
	this.messagePromises = {}
	
	if(this.connected)
	{
		this.connected = false;

		try {
			await Utils.toPromise(this.interop, "close")
		}
		catch(e)
		{
			Utils.logError(e);
		}

		this.cefTextures = {};
		this.shaders["afx_drawtexture_vs20"] = null;
		this.shaders["afx_drawtexture_ps20"] = null;
		this.vertexDeclarations["pos3_uv2"] = null;


		await Utils.toPromise(this.interop, "sendMessage", this.engineInteropId, JSON.stringify({
			"id": "drawingDisconnected",
			"port": "1",
			"args": [this.interop.id]
		}));

		await Utils.toPromise(this.interop, "sendMessage", this.args.indexInteropId, JSON.stringify({
			"id": "drawingDisconnected",
			"args": [this.interop.id]
		}));
	}
}

AfxDrawingInterop.prototype.setCefTexture = function(cefTextureHandle, cefTexture) {
    if(!this.cefTextures[cefTextureHandle.hi]){
        this.cefTextures[cefTextureHandle.hi] = {};
    }
    this.cefTextures[cefTextureHandle.hi][cefTextureHandle.lo] = cefTexture;
}

AfxDrawingInterop.prototype.getCefTexture = function(cefTextureHandle) {
	var loSet = this.cefTextures[cefTextureHandle.hi];
	if(loSet) {
		return loSet[cefTextureHandle.lo];
	}
}

AfxDrawingInterop.prototype.removeCefTexture = function(cefTextureHandle) {
	var loSet = this.cefTextures[cefTextureHandle.hi];
	if(loSet) {
		delete loSet[cefTextureHandle.lo];
	}
	if(0 == loSet.length)
	{
		delete this.cefTextures[cefTextureHandle.hi];
	}
}

////////////////////////////////////////////////////////////////////////////////

window.addEventListener('load', function(){

	console.log(window.afxInterop.args);
	new AfxDrawingInterop(window.afxInterop, JSON.parse(window.afxInterop.args))

}, false);

</script>
</body>
</html>